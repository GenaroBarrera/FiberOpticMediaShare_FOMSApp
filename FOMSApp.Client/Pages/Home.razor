@page "/"
@using FOMSApp.Shared.Models
@using Microsoft.JSInterop
@using System.Text.Json
@using System.Net
@using NetTopologySuite.IO.Converters
@using NetTopologySuite.Geometries
@using NetTopologySuite
@using System.Linq
@inject HttpClient Http
@inject IJSRuntime JS

<PageTitle>Fiber Map</PageTitle>

<h1>Fiber Network Map</h1>

@if (vaults == null || midpoints == null || cables == null)
{
    <p><em>Loading network data...</em></p>
}
else
{
    <!-- Toolbar for map editing modes with search bar on the same line -->
    <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2">
        <!-- Toolbar buttons on the left -->
        <div class="btn-toolbar" role="toolbar">
            <div class="btn-group" role="group">
                <button type="button" 
                        class="btn @(currentMode == MapMode.View ? "btn-primary" : "btn-outline-primary")"
                        @onclick="async () => await SetMode(MapMode.View)">
                    View
                </button>
                <button type="button" 
                        class="btn @(currentMode == MapMode.AddVault ? "btn-primary" : "btn-outline-primary")"
                        @onclick="async () => await SetMode(MapMode.AddVault)">
                    Add Vault
                </button>
                <button type="button" 
                        class="btn @(currentMode == MapMode.AddMidpoint ? "btn-primary" : "btn-outline-primary")"
                        @onclick="async () => await SetMode(MapMode.AddMidpoint)">
                    Add Midpoint
                </button>
                <button type="button" 
                        class="btn @(currentMode == MapMode.DrawCable ? "btn-primary" : "btn-outline-primary")"
                        @onclick="async () => await SetMode(MapMode.DrawCable)">
                    Draw Cable
                </button>
                <button type="button" 
                        class="btn @(currentMode == MapMode.Delete ? "btn-primary" : "btn-outline-primary")"
                        @onclick="async () => await SetMode(MapMode.Delete)">
                    Delete
                </button>
                <button type="button" 
                        class="btn btn-outline-secondary"
                        @onclick="async () => await UndoLastAction()"
                        disabled="@(undoHistory.Count == 0)"
                        title="@(undoHistory.Count > 0 ? $"Undo last action ({undoHistory.Count} available)" : "No actions to undo")">
                    <i class="bi bi-arrow-counterclockwise"></i> Undo
                </button>
                <button type="button" 
                        class="btn @(currentMode == MapMode.Select ? "btn-primary" : "btn-outline-primary")"
                        @onclick="async () => await SetMode(MapMode.Select)">
                    Select
                </button>
                <button type="button" 
                        class="btn btn-success"
                        @onclick="async () => await DownloadSelectedPhotos()"
                        disabled="@(isDownloadingSelected || (selectedVaultIds.Count == 0 && selectedMidpointIds.Count == 0))"
                        title="@(selectedVaultIds.Count + selectedMidpointIds.Count > 0 ? $"Download photos from {selectedVaultIds.Count + selectedMidpointIds.Count} selected item(s)" : "Select vaults or midpoints to download photos")">
                    @if (isDownloadingSelected)
                    {
                        <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                        <text>Downloading...</text>
                    }
                    else
                    {
                        <text><i class="bi bi-download"></i> Download Selected (@(selectedVaultIds.Count + selectedMidpointIds.Count))</text>
                    }
                </button>
            </div>
        </div>

        <!-- Map view toggle and search bar on the right -->
        <div class="d-flex align-items-center gap-2">
            <!-- Map view toggle button -->
            <button type="button" 
                    class="btn @(isSatelliteView ? "btn-success" : "btn-outline-secondary")"
                    @onclick="ToggleMapView"
                    title="@(isSatelliteView ? "Switch to default map" : "Switch to satellite view")">
                @if (isSatelliteView)
                {
                    <text><i class="bi bi-map"></i> Map</text>
                }
                else
                {
                    <text>üõ∞Ô∏è Satellite</text>
                }
            </button>

            <!-- Search Bar -->
            <div class="search-bar-container">
                <div class="input-group" style="width: 400px;">
                    <input type="text" 
                           class="form-control" 
                           placeholder="Search address or coordinates..." 
                           @bind="searchQuery"
                           @bind:event="oninput"
                           @onkeydown="HandleSearchKeyPress" />
                    <button type="button" 
                            class="btn btn-primary" 
                            @onclick="SearchLocation"
                            disabled="@isSearching">
                        @if (isSearching)
                        {
                            <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                            <text>Searching...</text>
                        }
                        else
                        {
                            <text><i class="bi bi-search"></i> Search</text>
                        }
                    </button>
                </div>
                @if (!string.IsNullOrWhiteSpace(searchError))
                {
                    <div class="alert alert-danger mt-2 mb-0" role="alert" style="width: 400px;">
                        @searchError
                    </div>
                }
            </div>
        </div>
    </div>

    <!-- Map wrapper - contains alerts and map container for consistent positioning -->
    <div class="map-wrapper">
        <!-- Map alerts container - positioned absolutely to not affect map container layout -->
        <div class="map-alerts-container">
            <!-- Status message for current mode -->
            @if (currentMode != MapMode.View)
            {
                <div class="alert alert-info" role="alert">
                    @GetModeInstructions()
                </div>
            }

            <!-- Cable drawing progress indicator -->
            @if (currentMode == MapMode.DrawCable && cablePoints.Count > 0)
            {
                <div class="alert alert-warning" role="alert">
                    Cable drawing in progress: @cablePoints.Count point(s) added. Click "Finish Cable" to save or "Cancel" to start over.
                    <button type="button" class="btn btn-sm btn-success ms-2" @onclick="FinishCable">Finish Cable</button>
                    <button type="button" class="btn btn-sm btn-danger ms-2" @onclick="CancelCable">Cancel</button>
                </div>
            }
        </div>

        <div id="map" class="map-container @GetMapCursorClass()"></div>
    </div>

    <!-- Edit Modal for Vaults and Midpoints -->
    @if (editingEntity != null)
    {
        <div class="modal-backdrop" @onclick="CloseEditModal"></div>
        <div class="modal fade show" style="display: block;" tabindex="-1" role="dialog" @onclick:stopPropagation="true">
            <div class="modal-dialog" role="document" @onclick:stopPropagation="true">
                <div class="modal-content" @onclick:stopPropagation="true">
                    <div class="modal-header">
                        <h5 class="modal-title">Edit @(editingEntity.Value.Type == "vault" ? "Vault" : editingEntity.Value.Type == "midpoint" ? "Midpoint" : "Cable")</h5>
                        <button type="button" class="btn-close" @onclick="CloseEditModal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        @if (editingEntity.Value.Type == "vault" && editingVaultModel != null)
                        {
                            <EditForm Model="@editingVaultModel" OnValidSubmit="@SaveVaultFromModal">
                                <DataAnnotationsValidator />
                                <div class="mb-3">
                                    <label for="editVaultName" class="form-label"><strong>Name:</strong></label>
                                    <InputText id="editVaultName" class="form-control" @bind-Value="editingVaultModel.Name" />
                                    <ValidationMessage For="@(() => editingVaultModel.Name)" />
                                </div>
                                <div class="mb-3">
                                    <label for="editVaultStatus" class="form-label"><strong>Status:</strong></label>
                                    <InputSelect id="editVaultStatus" class="form-select" @bind-Value="editingVaultModel.Status">
                                        <option value="@VaultStatus.New">New</option>
                                        <option value="@VaultStatus.Pending">Pending</option>
                                        <option value="@VaultStatus.Review">Review</option>
                                        <option value="@VaultStatus.Complete">Complete</option>
                                        <option value="@VaultStatus.Issue">Issue</option>
                                    </InputSelect>
                                    <ValidationMessage For="@(() => editingVaultModel.Status)" />
                                </div>
                                <div class="mb-3">
                                    <label for="editVaultDescription" class="form-label"><strong>Description:</strong></label>
                                    <InputTextArea id="editVaultDescription" class="form-control" rows="4" @bind-Value="editingVaultModel.Description" placeholder="Enter a brief description or notes..." />
                                    <ValidationMessage For="@(() => editingVaultModel.Description)" />
                                </div>
                                <div class="btn-group w-100">
                                    <button type="submit" class="btn btn-primary" disabled="@isSavingEntity">
                                        @if (isSavingEntity)
                                        {
                                            <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                                            <text>Saving...</text>
                                        }
                                        else
                                        {
                                            <text>Save Changes</text>
                                        }
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary" @onclick="CloseEditModal" disabled="@isSavingEntity">Cancel</button>
                                </div>
                            </EditForm>
                        }
                        else if (editingEntity.Value.Type == "midpoint" && editingMidpointModel != null)
                        {
                            <EditForm Model="@editingMidpointModel" OnValidSubmit="@SaveMidpointFromModal">
                                <DataAnnotationsValidator />
                                <div class="mb-3">
                                    <label for="editMidpointName" class="form-label"><strong>Name:</strong></label>
                                    <InputText id="editMidpointName" class="form-control" @bind-Value="editingMidpointModel.Name" />
                                    <ValidationMessage For="@(() => editingMidpointModel.Name)" />
                                </div>
                                <div class="mb-3">
                                    <label for="editMidpointStatus" class="form-label"><strong>Status:</strong></label>
                                    <InputSelect id="editMidpointStatus" class="form-select" @bind-Value="editingMidpointModel.Status">
                                        <option value="@MidpointStatus.New">New</option>
                                        <option value="@MidpointStatus.Review">Review</option>
                                        <option value="@MidpointStatus.Complete">Complete</option>
                                        <option value="@MidpointStatus.Issue">Issue</option>
                                    </InputSelect>
                                    <ValidationMessage For="@(() => editingMidpointModel.Status)" />
                                </div>
                                <div class="mb-3">
                                    <label for="editMidpointDescription" class="form-label"><strong>Description:</strong></label>
                                    <InputTextArea id="editMidpointDescription" class="form-control" rows="4" @bind-Value="editingMidpointModel.Description" placeholder="Enter a brief description or notes..." />
                                    <ValidationMessage For="@(() => editingMidpointModel.Description)" />
                                </div>
                                <div class="btn-group w-100">
                                    <button type="submit" class="btn btn-primary" disabled="@isSavingEntity">
                                        @if (isSavingEntity)
                                        {
                                            <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                                            <text>Saving...</text>
                                        }
                                        else
                                        {
                                            <text>Save Changes</text>
                                        }
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary" @onclick="CloseEditModal" disabled="@isSavingEntity">Cancel</button>
                                </div>
                            </EditForm>
                        }
                        else if (editingEntity.Value.Type == "cable" && editingCableModel != null)
                        {
                            <EditForm Model="@editingCableModel" OnValidSubmit="@SaveCableFromModal">
                                <DataAnnotationsValidator />
                                <div class="mb-3">
                                    <label for="editCableName" class="form-label"><strong>Name:</strong></label>
                                    <InputText id="editCableName" class="form-control" @bind-Value="editingCableModel.Name" />
                                    <ValidationMessage For="@(() => editingCableModel.Name)" />
                                </div>
                                <div class="mb-3">
                                    <label for="editCableDescription" class="form-label"><strong>Description:</strong></label>
                                    <InputTextArea id="editCableDescription" class="form-control" rows="4" @bind-Value="editingCableModel.Description" placeholder="Enter a brief description or notes..." />
                                    <ValidationMessage For="@(() => editingCableModel.Description)" />
                                </div>
                                <div class="mb-3">
                                    <label for="editCableColor" class="form-label"><strong>Color:</strong></label>
                                    <InputSelect id="editCableColor" class="form-select" @bind-Value="editingCableModel.Color">
                                        <option value="Black">Black</option>
                                        <option value="Blue">Blue</option>
                                        <option value="Orange">Orange</option>
                                        <option value="Green">Green</option>
                                        <option value="Brown">Brown</option>
                                        <option value="Pink">Pink</option>
                                        <option value="Teal">Teal</option>
                                    </InputSelect>
                                    <ValidationMessage For="@(() => editingCableModel.Color)" />
                                </div>
                                <div class="btn-group w-100">
                                    <button type="submit" class="btn btn-primary" disabled="@isSavingEntity">
                                        @if (isSavingEntity)
                                        {
                                            <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                                            <text>Saving...</text>
                                        }
                                        else
                                        {
                                            <text>Save Changes</text>
                                        }
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary" @onclick="CloseEditModal" disabled="@isSavingEntity">Cancel</button>
                                </div>
                            </EditForm>
                        }
                    </div>
                </div>
            </div>
        </div>
    }
}

@implements IDisposable

@code {
    // Enumeration defining the different interaction modes for the map editor.
    private enum MapMode
    {
        View,           // Default mode - no editing, just viewing
        AddVault,       // Click on map to create a new vault
        AddMidpoint,    // Click on map to create a new midpoint
        DrawCable,      // Click multiple points to define a cable path
        Delete,         // Click on existing items to delete them
        Select          // Click on vaults/midpoints to select them for batch operations
    }

    private Vault[]? vaults;
    private Midpoint[]? midpoints;
    private Cable[]? cables;
    
    private IJSObjectReference? module;
    private IJSObjectReference? mapInstance;
    
    // Current interaction mode for the map editor.
    private MapMode currentMode = MapMode.View;

    // Search query entered by the user (address or coordinates).
    private string searchQuery = string.Empty;

    // Error message to display if search fails.
    private string? searchError;

    // Indicates whether a search operation is currently in progress.
    // Used to disable the search button and show a loading spinner during search.
    private bool isSearching = false;

    // Indicates whether the map is currently displaying satellite view (true) or default map view (false).
    private bool isSatelliteView = false;

    // Set of vault IDs that have been selected for batch operations (e.g., downloading photos).
    private HashSet<int> selectedVaultIds = new();

    // Set of midpoint IDs that have been selected for batch operations (e.g., downloading photos).
    private HashSet<int> selectedMidpointIds = new();

    // Indicates whether photos are currently being downloaded for selected entities.
    // Used to disable the download button and show a loading state during download.
    private bool isDownloadingSelected = false;
    
    // Temporary storage for points collected while drawing a cable.
    private List<(double Lat, double Lng)> cablePoints = new();
    
    // Temporary polyline reference for previewing the cable being drawn.
    private IJSObjectReference? tempCablePolyline;

    // Temporary markers for cable points while drawing (white circles).
    private List<IJSObjectReference> tempCableMarkers = new();

    // Dictionary to store vertex markers for each cable (key: cableId, value: list of vertex markers).
    private Dictionary<int, List<IJSObjectReference>> cableVertexMarkers = new();

    // ID of the currently selected cable (if any). Vertex markers are shown for the selected cable.
    private int? selectedCableId = null;

    // Information about the entity currently being edited in the modal (vault or midpoint).
    private (string Type, int Id)? editingEntity = null;

    // Edit model for vault editing in the modal.
    private VaultEditModel? editingVaultModel = null;

    // Edit model for midpoint editing in the modal.
    private MidpointEditModel? editingMidpointModel = null;

    // Edit model for cable editing in the modal.
    private CableEditModel? editingCableModel = null;

    // Indicates whether an entity save operation is in progress.
    private bool isSavingEntity = false;

    // Dictionary to store map layer references (markers, circles, polylines) with their entity IDs.
    // Used to identify which item was clicked for deletion.
    // Key: Entity ID (vault/midpoint/cable ID), Value: JavaScript object reference to the Leaflet layer
    private Dictionary<string, IJSObjectReference> mapLayers = new();

    // .NET object reference for JavaScript interop callbacks.
    // Used to allow JavaScript to call back into C# methods (e.g., for delete functionality).
    private DotNetObjectReference<Home>? dotNetReference;

    // Enumeration of action types that can be undone.
    private enum UndoActionType
    {
        Delete,
        Edit,
        Move
    }

    // Represents a single undo history entry containing the action type, entity information, and previous state.
    private class UndoHistoryEntry
    {
        // The type of action performed (Delete, Edit, or Move).
        public UndoActionType ActionType { get; set; }

        // The type of entity affected ("vault", "midpoint", or "cable").
        public string EntityType { get; set; } = string.Empty;

        // The unique ID of the entity that was affected.
        public int EntityId { get; set; }

        // Serialized JSON representation of the entity's state before the action.
        // Used to restore the entity to its previous state when undoing.
        public string PreviousStateJson { get; set; } = string.Empty;
    }

    // Stack of undo history entries. The most recent action is at the top of the stack.
    // Limited to 50 entries to prevent excessive memory usage.
    private Stack<UndoHistoryEntry> undoHistory = new();

    protected override async Task OnInitializedAsync()
    {
        try 
        {
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());

            // Fetch all three data types
            vaults = await Http.GetFromJsonAsync<Vault[]>("api/vaults", options);
            midpoints = await Http.GetFromJsonAsync<Midpoint[]>("api/midpoints", options);
            cables = await Http.GetFromJsonAsync<Cable[]>("api/cables", options);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"DATA FETCH ERROR: {ex.Message}");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (mapInstance == null && vaults != null && midpoints != null && cables != null)
        {
            try 
            {
                module = await JS.InvokeAsync<IJSObjectReference>("import", "./mapHelper.js");
                mapInstance = await module.InvokeAsync<IJSObjectReference>("initMap", "map");

                // Setup click event listener for map interactions (needed for delete mode)
                dotNetReference = DotNetObjectReference.Create(this);
                await SetupMapClickListener();
                
                // Initialize delete and select mode state in JavaScript
                await module.InvokeVoidAsync("setDeleteMode", currentMode == MapMode.Delete);
                await module.InvokeVoidAsync("setSelectMode", currentMode == MapMode.Select);

                // 1. Draw VAULTS (Pins) - Store layer references for deletion
                foreach (var vault in vaults)
                {
                    if (vault.Location != null)
                    {
                        // Load photos for this vault
                        List<Photo>? vaultPhotos = null;
                        try
                        {
                            vaultPhotos = await Http.GetFromJsonAsync<List<Photo>>($"api/photos/vault/{vault.Id}");
                        }
                        catch
                        {
                            // If photos fail to load, continue without them
                        }

                        // Build popup content with labeled fields: Name, Photos (if any), Status, Description, Coordinates, and link to details
                        string descriptionText = string.IsNullOrWhiteSpace(vault.Description) 
                            ? "No description provided." 
                            : System.Net.WebUtility.HtmlEncode(vault.Description);
                        string coordinates = $"{vault.Location.Y:F6}, {vault.Location.X:F6}";
                        // Create a unique ID for the edit button to avoid conflicts
                        string editButtonId = $"editVault_{vault.Id}";
                        string photosHtml = BuildPhotosHtml(vault.Id, vaultPhotos, "vault");
                        
                        string popup = $"<div style='font-size: 12px; line-height: 1.6; width: 300px;'>" +
                            $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(vault.Name)}<br>" +
                            photosHtml +
                            $"<strong>Status:</strong> {vault.Status}<br>" +
                            $"<strong>Description:</strong> {descriptionText}<br>" +
                            $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                            $"<div style='margin-top: 8px;'>" +
                            $"<button id='{editButtonId}' class='btn btn-sm btn-primary me-2' style='font-size: 11px; padding: 2px 8px;'>Edit</button>" +
                            $"<a href='vault/{vault.Id}' style='font-size: 11px;'>View Details</a>" +
                            $"</div>" +
                            $"</div>";
                        // Ensure we have a valid color (use status-based color if Color is not set)
                        string vaultColor = !string.IsNullOrWhiteSpace(vault.Color) ? vault.Color : GetStatusColor(vault.Status);
                        // Check if this vault is selected for highlighting
                        bool isSelected = selectedVaultIds.Contains(vault.Id);
                        // Pass the vault's Color property to display the marker in the correct status color
                        var markerRef = await module.InvokeAsync<IJSObjectReference>("addMarker", mapInstance, vault.Location.Y, vault.Location.X, popup, vault.Id, dotNetReference, vaultColor, isSelected);
                        mapLayers[$"vault_{vault.Id}"] = markerRef;
                        
                        // Attach edit button handler
                        await module.InvokeVoidAsync("attachEditButtonHandler", markerRef, editButtonId, "vault", vault.Id, dotNetReference);
                    }
                }

                // 2. Draw MIDPOINTS (Diamond/Square markers) - Store layer references for deletion
                foreach (var mp in midpoints)
                {
                    if (mp.Location != null)
                    {
                        // Load photos for this midpoint
                        List<Photo>? midpointPhotos = null;
                        try
                        {
                            midpointPhotos = await Http.GetFromJsonAsync<List<Photo>>($"api/photos/midpoint/{mp.Id}");
                        }
                        catch
                        {
                            // If photos fail to load, continue without them
                        }

                        // Build popup content with labeled fields: Name, Photos (if any), Status, Description, Coordinates, and link to details
                        string descriptionText = string.IsNullOrWhiteSpace(mp.Description) 
                            ? "No description provided." 
                            : System.Net.WebUtility.HtmlEncode(mp.Description);
                        string coordinates = $"{mp.Location.Y:F6}, {mp.Location.X:F6}";
                        // Create a unique ID for the edit button to avoid conflicts
                        string editButtonId = $"editMidpoint_{mp.Id}";
                        string photosHtml = BuildPhotosHtml(mp.Id, midpointPhotos, "midpoint");
                        
                        string popup = $"<div style='font-size: 12px; line-height: 1.6; width: 300px;'>" +
                            $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(mp.Name)}<br>" +
                            photosHtml +
                            $"<strong>Status:</strong> {mp.Status}<br>" +
                            $"<strong>Description:</strong> {descriptionText}<br>" +
                            $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                            $"<div style='margin-top: 8px;'>" +
                            $"<button id='{editButtonId}' class='btn btn-sm btn-primary me-2' style='font-size: 11px; padding: 2px 8px;'>Edit</button>" +
                            $"<a href='midpoint/{mp.Id}' style='font-size: 11px;'>View Details</a>" +
                            $"</div>" +
                            $"</div>";
                        // Check if this midpoint is selected for highlighting
                        bool isSelected = selectedMidpointIds.Contains(mp.Id);
                        string midpointColor = !string.IsNullOrWhiteSpace(mp.Color) ? mp.Color : GetMidpointStatusColor(mp.Status);
                        var circleRef = await module.InvokeAsync<IJSObjectReference>("addCircle", mapInstance, mp.Location.Y, mp.Location.X, midpointColor, popup, mp.Id, dotNetReference, isSelected);
                        mapLayers[$"midpoint_{mp.Id}"] = circleRef;
                        
                        // Attach edit button handler
                        await module.InvokeVoidAsync("attachEditButtonHandler", circleRef, editButtonId, "midpoint", mp.Id, dotNetReference);
                    }
                }

                // 3. Draw CABLES (Lines) with editable vertices - Store layer references for deletion
                foreach (var cable in cables)
                {
                    if (cable.Path != null)
                    {
                        await DrawCableWithVertices(cable);
                    }
                }
            }
            catch(Exception ex)
            {
                Console.WriteLine($"MAP RENDER ERROR: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
                // Show error to user if map fails to render
                await JS.InvokeVoidAsync("alert", $"Failed to initialize map: {ex.Message}");
            }
        }
        else if (!firstRender && mapInstance != null && module != null)
        {
            // After non-initial renders, ensure map size is correct
            // This prevents size issues when alerts appear/disappear
            await Task.Delay(100); // Small delay to allow DOM to settle
            await module.InvokeVoidAsync("invalidateMapSize", mapInstance);
        }
    }

    // Sets up the click event listener on the map to handle user interactions based on the current mode.
    private async Task SetupMapClickListener()
    {
        if (module != null && mapInstance != null)
        {
            // Register a callback that will be invoked from JavaScript when the map is clicked
            var dotNetReference = DotNetObjectReference.Create(this);
            await module.InvokeVoidAsync("addClickEventListener", mapInstance, dotNetReference);
        }
    }

    // Handles clicks on map entities (vaults, midpoints, cables) when in Delete or Select mode.
    // This method is called from JavaScript when a user clicks on a marker, circle, or polyline.
    // <param name="entityType">The type of entity clicked: "vault", "midpoint", or "cable"</param>
    // <param name="entityId">The unique ID of the entity</param>
    [JSInvokable]
    public async Task OnEntityClick(string entityType, int entityId)
    {
        // Log for debugging
        Console.WriteLine($"OnEntityClick called: type={entityType}, id={entityId}, currentMode={currentMode}");
        
        // Handle selection mode
        if (currentMode == MapMode.Select)
        {
            string lowerType = entityType.ToLower();
            if (lowerType == "vault")
            {
                if (selectedVaultIds.Contains(entityId))
                {
                    selectedVaultIds.Remove(entityId);
                }
                else
                {
                    selectedVaultIds.Add(entityId);
                }
                StateHasChanged();
                // Update marker visual to reflect selection state
                await UpdateVaultMarkerSelection(entityId);
            }
            else if (lowerType == "midpoint")
            {
                if (selectedMidpointIds.Contains(entityId))
                {
                    selectedMidpointIds.Remove(entityId);
                }
                else
                {
                    selectedMidpointIds.Add(entityId);
                }
                StateHasChanged();
                // Update marker visual to reflect selection state
                await UpdateMidpointMarkerSelection(entityId);
            }
            return;
        }
        
        // Only handle deletion if we're in Delete mode
        if (currentMode != MapMode.Delete)
        {
            Console.WriteLine($"Not in delete or select mode, ignoring click. Current mode: {currentMode}");
            return;
        }

        try
        {
            // Show confirmation dialog
            var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to delete this {entityType}?");
            if (!confirmed)
            {
                return;
            }

            // Delete based on entity type
            switch (entityType.ToLower())
            {
                case "vault":
                    await DeleteVault(entityId);
                    break;
                case "midpoint":
                    await DeleteMidpoint(entityId);
                    break;
                case "cable":
                    await DeleteCable(entityId);
                    break;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ERROR deleting {entityType}: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Failed to delete {entityType}. Error: {ex.Message}");
        }
    }

    // Handles marker drag end events when a user moves a vault or midpoint marker to a new location.
    // This method is called from JavaScript when a marker is dragged and released.
    // <param name="entityType">The type of entity moved: "vault" or "midpoint"</param>
    // <param name="entityId">The unique ID of the entity that was moved</param>
    // <param name="newLat">The new latitude coordinate after the drag</param>
    // <param name="newLng">The new longitude coordinate after the drag</param>
    [JSInvokable]
    public async Task OnMarkerDragEnd(string entityType, int entityId, double newLat, double newLng)
    {
        // Log for debugging
        Console.WriteLine($"OnMarkerDragEnd called: type={entityType}, id={entityId}, newLat={newLat}, newLng={newLng}");

        try
        {
            // Update location based on entity type
            switch (entityType.ToLower())
            {
                case "vault":
                    await UpdateVaultLocation(entityId, newLat, newLng);
                    break;
                case "midpoint":
                    await UpdateMidpointLocation(entityId, newLat, newLng);
                    break;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ERROR updating {entityType} location: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Failed to update {entityType} location. Error: {ex.Message}");
        }
    }

    // Handles map click events from JavaScript. This method is called via JSInterop when the user clicks on the map.
    // <param name="lat">Latitude of the click location.</param>
    // <param name="lng">Longitude of the click location.</param>
    [JSInvokable]
    public async Task OnMapClick(double lat, double lng)
    {
        if (currentMode == MapMode.View)
        {
            // In view mode, clicks don't do anything
            return;
        }

        try
        {
            switch (currentMode)
            {
                case MapMode.AddVault:
                    await CreateVaultAtLocation(lat, lng);
                    break;

                case MapMode.AddMidpoint:
                    await CreateMidpointAtLocation(lat, lng);
                    break;

                case MapMode.DrawCable:
                    await AddCablePoint(lat, lng);
                    break;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ERROR handling map click: {ex.Message}");
        }

        // Trigger UI update
        StateHasChanged();
    }

    // Changes the current map interaction mode and provides user feedback.
    // <param name="mode">The mode to switch to.</param>
    private async Task SetMode(MapMode mode)
    {
        try
        {
            // If clicking Select button again while already in Select mode, toggle to View mode
            if (currentMode == MapMode.Select && mode == MapMode.Select)
            {
                mode = MapMode.View;
            }

            // If switching away from DrawCable mode, cancel any in-progress cable
            if (currentMode == MapMode.DrawCable && mode != MapMode.DrawCable)
            {
                await CancelCable();
            }

            // Clear selections when switching away from Select mode or when toggling Select off
            bool wasInSelectMode = currentMode == MapMode.Select;
            bool isLeavingSelectMode = wasInSelectMode && mode != MapMode.Select;
            
            if (isLeavingSelectMode || mode != MapMode.Select)
            {
                // Clear selections and update marker visuals
                await ClearAllSelections();
            }

            currentMode = mode;

            // Update JavaScript delete mode state so click handlers know the current mode
            if (module != null)
            {
                await module.InvokeVoidAsync("setDeleteMode", mode == MapMode.Delete);
                await module.InvokeVoidAsync("setSelectMode", mode == MapMode.Select);
            }

            // Ensure map size is recalculated after mode change to prevent size issues
            // Use a small delay to allow DOM to update first
            if (mapInstance != null && module != null)
            {
                await Task.Delay(50); // Small delay to allow DOM updates
                await module.InvokeVoidAsync("invalidateMapSize", mapInstance);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in SetMode: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
            // Don't show alert for mode switching errors - just log them
        }
    }

    // Returns user-friendly instructions for the current map mode.
    private string GetModeInstructions()
    {
        return currentMode switch
        {
            MapMode.AddVault => "Click on the map to add a new vault at that location.",
            MapMode.AddMidpoint => "Click on the map to add a new midpoint at that location.",
            MapMode.DrawCable => "Click multiple points on the map to define the cable path. Click 'Finish Cable' when done.",
            MapMode.Delete => "Click on a vault, midpoint, or cable to delete it.",
            MapMode.Select => "Click on vaults or midpoints to select them. Use 'Download Selected' to download photos from selected items.",
            _ => ""
        };
    }

    // Returns the CSS class name for the map cursor based on the current editing mode.
    // This provides visual feedback to users about what action they can perform.
    // <returns>A CSS class name that sets the appropriate cursor style</returns>
    private string GetMapCursorClass()
    {
        return currentMode switch
        {
            MapMode.View => "cursor-default",
            MapMode.AddVault => "cursor-crosshair",
            MapMode.AddMidpoint => "cursor-crosshair",
            MapMode.DrawCable => "cursor-crosshair",
            MapMode.Delete => "cursor-pointer",
            MapMode.Select => "cursor-pointer",
            _ => "cursor-default"
        };
    }

    // Creates a new vault at the specified geographic coordinates.
    // <param name="lat">Latitude of the vault location.</param>
    // <param name="lng">Longitude of the vault location.</param>
    private async Task CreateVaultAtLocation(double lat, double lng)
    {
        if (module == null || mapInstance == null) return;

        // Prompt user for vault name
        var vaultName = await JS.InvokeAsync<string>("prompt", "Enter vault name:");
        if (string.IsNullOrWhiteSpace(vaultName))
        {
            return; // User cancelled
        }

        // Create Point geometry (NetTopologySuite uses X for Longitude, Y for Latitude)
        // SRID 4326 is the standard for GPS (WGS 84)
        var factory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
        var location = factory.CreatePoint(new Coordinate(lng, lat));

        // Create the vault object
        var newVault = new Vault
        {
            Name = vaultName,
            Location = location,
            Status = VaultStatus.New, // New vaults start as "New" (blue)
            Color = GetStatusColor(VaultStatus.New) // Set color based on status
        };

        // Serialize with GeoJSON support
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());

        // POST to API
        var response = await Http.PostAsJsonAsync("api/vaults", newVault, options);
        
        if (response.IsSuccessStatusCode)
        {
            var createdVault = await response.Content.ReadFromJsonAsync<Vault>(options);
            
            if (createdVault != null && createdVault.Location != null && dotNetReference != null)
            {
                // Load photos for this vault (likely empty for new vaults, but check anyway)
                List<Photo>? vaultPhotos = null;
                try
                {
                    vaultPhotos = await Http.GetFromJsonAsync<List<Photo>>($"api/photos/vault/{createdVault.Id}");
                }
                catch
                {
                    // If photos fail to load, continue without them
                }

                // Add marker to map immediately and store reference for deletion
                // Build popup content with labeled fields: Name, Photos (if any), Status, Description, Coordinates, Edit button, and link to details
                string descriptionText = string.IsNullOrWhiteSpace(createdVault.Description) 
                    ? "No description provided." 
                    : System.Net.WebUtility.HtmlEncode(createdVault.Description);
                string coordinates = $"{createdVault.Location.Y:F6}, {createdVault.Location.X:F6}";
                string editButtonId = $"editVault_{createdVault.Id}";
                string photosHtml = BuildPhotosHtml(createdVault.Id, vaultPhotos, "vault");
                string popup = $"<div style='font-size: 12px; line-height: 1.6; width: 300px;'>" +
                    $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(createdVault.Name)}<br>" +
                    photosHtml +
                    $"<strong>Status:</strong> {createdVault.Status}<br>" +
                    $"<strong>Description:</strong> {descriptionText}<br>" +
                    $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                    $"<div style='margin-top: 8px;'>" +
                    $"<button id='{editButtonId}' class='btn btn-sm btn-primary me-2' style='font-size: 11px; padding: 2px 8px;'>Edit</button>" +
                    $"<a href='vault/{createdVault.Id}' style='font-size: 11px;'>View Details</a>" +
                    $"</div>" +
                    $"</div>";
                // Pass the vault's Color property to display the marker in the correct status color
                var markerRef = await module.InvokeAsync<IJSObjectReference>("addMarker", mapInstance, createdVault.Location.Y, createdVault.Location.X, popup, createdVault.Id, dotNetReference, createdVault.Color);
                mapLayers[$"vault_{createdVault.Id}"] = markerRef;
                
                // Attach edit button handler
                await module.InvokeVoidAsync("attachEditButtonHandler", markerRef, editButtonId, "vault", createdVault.Id, dotNetReference);

                // Refresh the vaults list
                await LoadVaults();
            }
        }
    }

    // Creates a new midpoint at the specified geographic coordinates.
    // <param name="lat">Latitude of the midpoint location.</param>
    // <param name="lng">Longitude of the midpoint location.</param>
    private async Task CreateMidpointAtLocation(double lat, double lng)
    {
        if (module == null || mapInstance == null) return;

        // Prompt user for midpoint name
        var midpointName = await JS.InvokeAsync<string>("prompt", "Enter midpoint name:");
        if (string.IsNullOrWhiteSpace(midpointName))
        {
            return; // User cancelled
        }

        // Create Point geometry
        // SRID 4326 is the standard for GPS (WGS 84)
        var factory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
        var location = factory.CreatePoint(new Coordinate(lng, lat));

        // Create the midpoint object
        var newMidpoint = new Midpoint
        {
            Name = midpointName,
            Location = location,
            Status = MidpointStatus.New, // New midpoints start as "New" (black)
            Color = GetMidpointStatusColor(MidpointStatus.New) // Set color based on status
        };

        // Serialize with GeoJSON support
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());

        // POST to API
        var response = await Http.PostAsJsonAsync("api/midpoints", newMidpoint, options);
        
        if (response.IsSuccessStatusCode)
        {
            var createdMidpoint = await response.Content.ReadFromJsonAsync<Midpoint>(options);
            
            if (createdMidpoint != null && createdMidpoint.Location != null && dotNetReference != null)
            {
                // Load photos for this midpoint (likely empty for new midpoints, but check anyway)
                List<Photo>? midpointPhotos = null;
                try
                {
                    midpointPhotos = await Http.GetFromJsonAsync<List<Photo>>($"api/photos/midpoint/{createdMidpoint.Id}");
                }
                catch
                {
                    // If photos fail to load, continue without them
                }

                // Add circle to map immediately and store reference for deletion
                // Build popup content with labeled fields: Name, Photos (if any), Status, Description, Coordinates, Edit button, and link to details
                string descriptionText = string.IsNullOrWhiteSpace(createdMidpoint.Description) 
                    ? "No description provided." 
                    : System.Net.WebUtility.HtmlEncode(createdMidpoint.Description);
                string coordinates = $"{createdMidpoint.Location.Y:F6}, {createdMidpoint.Location.X:F6}";
                string editButtonId = $"editMidpoint_{createdMidpoint.Id}";
                string photosHtml = BuildPhotosHtml(createdMidpoint.Id, midpointPhotos, "midpoint");
                string popup = $"<div style='font-size: 12px; line-height: 1.6; width: 300px;'>" +
                    $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(createdMidpoint.Name)}<br>" +
                    photosHtml +
                    $"<strong>Status:</strong> {createdMidpoint.Status}<br>" +
                    $"<strong>Description:</strong> {descriptionText}<br>" +
                    $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                    $"<div style='margin-top: 8px;'>" +
                    $"<button id='{editButtonId}' class='btn btn-sm btn-primary me-2' style='font-size: 11px; padding: 2px 8px;'>Edit</button>" +
                    $"<a href='midpoint/{createdMidpoint.Id}' style='font-size: 11px;'>View Details</a>" +
                    $"</div>" +
                    $"</div>";
                // Pass the midpoint's Color property to display the marker in the correct status color
                var circleRef = await module.InvokeAsync<IJSObjectReference>("addCircle", mapInstance, createdMidpoint.Location.Y, createdMidpoint.Location.X, createdMidpoint.Color, popup, createdMidpoint.Id, dotNetReference);
                mapLayers[$"midpoint_{createdMidpoint.Id}"] = circleRef;
                
                // Attach edit button handler
                await module.InvokeVoidAsync("attachEditButtonHandler", circleRef, editButtonId, "midpoint", createdMidpoint.Id, dotNetReference);

                // Refresh the midpoints list
                await LoadMidpoints();
            }
        }
    }

    // Adds a point to the current cable being drawn and updates the preview polyline.
    // Shows white circle markers at each point as it's added (similar to Google My Maps).
    // <param name="lat">Latitude of the point.</param>
    // <param name="lng">Longitude of the point.</param>
    private async Task AddCablePoint(double lat, double lng)
    {
        if (module == null || mapInstance == null) return;

        // Add point to collection
        cablePoints.Add((lat, lng));

        // Add a white circle marker at this point (visible vertex)
        var marker = await module.InvokeAsync<IJSObjectReference>("addCableVertexMarker", mapInstance, lat, lng);
        tempCableMarkers.Add(marker);

        // If we have at least 2 points, draw/update the preview polyline
        if (cablePoints.Count >= 2)
        {
            // Remove previous preview if it exists
            if (tempCablePolyline != null)
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, tempCablePolyline);
            }

            // Create array of coordinates for the preview
            var latLngs = cablePoints.Select(p => new { lat = p.Lat, lng = p.Lng }).ToList<object>();
            
            // Draw preview polyline in orange
            tempCablePolyline = await module.InvokeAsync<IJSObjectReference>("addPolyline", mapInstance, latLngs, "Orange", "Preview - Click 'Finish Cable' to save");
        }
    }

    // Completes the cable drawing by saving the collected points as a LineString to the database.
    private async Task FinishCable()
    {
        if (cablePoints.Count < 2)
        {
            await JS.InvokeVoidAsync("alert", "A cable needs at least 2 points. Please add more points before finishing.");
            return;
        }

        // Prompt user for cable name
        var cableName = await JS.InvokeAsync<string>("prompt", "Enter cable name:");
        if (string.IsNullOrWhiteSpace(cableName))
        {
            return; // User cancelled
        }

        // Create LineString from collected points (NetTopologySuite uses X for Longitude, Y for Latitude)
        // SRID 4326 is the standard for GPS (WGS 84)
        var factory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
        var coordinates = cablePoints.Select(p => new Coordinate(p.Lng, p.Lat)).ToArray();
        var lineString = factory.CreateLineString(coordinates);

        // Create the cable object with default black color
        var newCable = new Cable
        {
            Name = cableName,
            Path = lineString,
            Color = "Black" // Default color for newly drawn cables
        };

        // Serialize with GeoJSON support
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());

        // POST to API
        var response = await Http.PostAsJsonAsync("api/cables", newCable, options);
        
        if (response.IsSuccessStatusCode)
        {
            var createdCable = await response.Content.ReadFromJsonAsync<Cable>(options);
            
            if (createdCable != null && createdCable.Path != null && module != null && mapInstance != null)
            {
                // Remove preview polyline and temporary markers
                if (tempCablePolyline != null)
                {
                    await module.InvokeVoidAsync("removeLayer", mapInstance, tempCablePolyline);
                    tempCablePolyline = null;
                }
                
                // Remove all temporary markers
                foreach (var marker in tempCableMarkers)
                {
                    await module.InvokeVoidAsync("removeLayer", mapInstance, marker);
                }
                tempCableMarkers.Clear();

                // Draw the saved cable with editable vertices
                await DrawCableWithVertices(createdCable);

                // Refresh the cables list
                await LoadCables();
            }

            // Reset cable drawing state
            cablePoints.Clear();
            currentMode = MapMode.View;
        }
    }

    // Cancels the current cable drawing operation and clears the preview.
    private async Task CancelCable()
    {
        if (module != null && mapInstance != null)
        {
            if (tempCablePolyline != null)
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, tempCablePolyline);
                tempCablePolyline = null;
            }
            
            // Remove all temporary markers
            foreach (var marker in tempCableMarkers)
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, marker);
            }
            tempCableMarkers.Clear();
        }
        cablePoints.Clear();
        currentMode = MapMode.View;
    }

    // Draws a cable on the map with editable vertex markers (white circles).
    // Each vertex can be dragged to adjust the cable shape.
    // <param name="cable">The cable to draw</param>
    private async Task DrawCableWithVertices(Cable cable)
    {
        if (module == null || mapInstance == null || cable.Path == null || dotNetReference == null)
            return;

        // Remove existing cable and vertex markers if they exist (for redrawing after updates)
        if (mapLayers.ContainsKey($"cable_{cable.Id}"))
        {
            await module.InvokeVoidAsync("removeLayer", mapInstance, mapLayers[$"cable_{cable.Id}"]);
            mapLayers.Remove($"cable_{cable.Id}");
        }
        
        if (cableVertexMarkers.ContainsKey(cable.Id))
        {
            foreach (var vertexMarker in cableVertexMarkers[cable.Id])
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, vertexMarker);
            }
            cableVertexMarkers.Remove(cable.Id);
        }

        // Convert coordinates to Leaflet format
        var latLngs = new List<object>();
        foreach (var coord in cable.Path.Coordinates)
        {
            latLngs.Add(new { lat = coord.Y, lng = coord.X });
        }

        // Build popup content
        string descriptionText = string.IsNullOrWhiteSpace(cable.Description) 
            ? "No description provided." 
            : System.Net.WebUtility.HtmlEncode(cable.Description);
        string lengthText = GetCableLengthForPopup(cable);
        string editButtonId = $"editCable_{cable.Id}";
        string popup = $"<div style='font-size: 12px; line-height: 1.6;'>" +
            $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(cable.Name)}<br>" +
            $"<strong>Description:</strong> {descriptionText}<br>" +
            $"<strong>Color:</strong> {cable.Color}<br>" +
            $"<strong>Length:</strong> {lengthText}<br>" +
            $"<div style='margin-top: 8px;'>" +
            $"<button id='{editButtonId}' class='btn btn-sm btn-primary me-2' style='font-size: 11px; padding: 2px 8px;'>Edit</button>" +
            $"<a href='cable/{cable.Id}' style='font-size: 11px;'>View Details</a>" +
            $"</div>" +
            $"</div>";

        // Draw the polyline with drag support
        var polylineRef = await module.InvokeAsync<IJSObjectReference>("addEditablePolyline", 
            mapInstance, latLngs, cable.Color, popup, cable.Id, dotNetReference);
        mapLayers[$"cable_{cable.Id}"] = polylineRef;

        // Store vertex markers for this cable
        var vertexMarkers = new List<IJSObjectReference>();
        int vertexIndex = 0;
        foreach (var coord in cable.Path.Coordinates)
        {
            var vertexMarker = await module.InvokeAsync<IJSObjectReference>("addCableVertexMarker", 
                mapInstance, coord.Y, coord.X);
            
            // Make the vertex marker draggable and connect it to the cable
            // This returns a draggable marker (replaces the circle marker)
            var draggableMarker = await module.InvokeAsync<IJSObjectReference>("makeVertexDraggable", 
                mapInstance, vertexMarker, cable.Id, vertexIndex, polylineRef, dotNetReference);
            
            vertexMarkers.Add(draggableMarker);
            vertexIndex++;
        }
        
        cableVertexMarkers[cable.Id] = vertexMarkers;
        
        // Attach edit button handler for cable popup
        await module.InvokeVoidAsync("attachEditButtonHandler", polylineRef, editButtonId, "cable", cable.Id, dotNetReference);
        
        // Hide vertex markers by default (only show when cable is selected or dragging)
        // Only show if this cable is currently selected
        if (selectedCableId == cable.Id)
        {
            await ShowCableVertices(cable.Id);
        }
        else
        {
            await HideCableVertices(cable.Id);
        }
    }

    // Shows the vertex markers for a specific cable.
    // <param name="cableId">The ID of the cable whose vertices should be shown</param>
    private async Task ShowCableVertices(int cableId)
    {
        if (module == null || mapInstance == null || !cableVertexMarkers.ContainsKey(cableId))
            return;

        foreach (var vertexMarker in cableVertexMarkers[cableId])
        {
            await module.InvokeVoidAsync("showLayer", mapInstance, vertexMarker);
        }
    }

    // Hides the vertex markers for a specific cable.
    // <param name="cableId">The ID of the cable whose vertices should be hidden</param>
    private async Task HideCableVertices(int cableId)
    {
        if (module == null || mapInstance == null || !cableVertexMarkers.ContainsKey(cableId))
            return;

        foreach (var vertexMarker in cableVertexMarkers[cableId])
        {
            await module.InvokeVoidAsync("hideLayer", mapInstance, vertexMarker);
        }
    }

    // Reloads the vaults from the API and refreshes the display.
    private async Task LoadVaults()
    {
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());
        vaults = await Http.GetFromJsonAsync<Vault[]>("api/vaults", options);
    }

    // Reloads the midpoints from the API and refreshes the display.
    private async Task LoadMidpoints()
    {
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());
        midpoints = await Http.GetFromJsonAsync<Midpoint[]>("api/midpoints", options);
    }

    // Reloads the cables from the API and refreshes the display.
    private async Task LoadCables()
    {
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());
        cables = await Http.GetFromJsonAsync<Cable[]>("api/cables", options);
    }

    // Deletes a vault from the database and removes it from the map.
    // Also adds the deletion to the undo history so it can be undone.
    // <param name="vaultId">The unique ID of the vault to delete</param>
    private async Task DeleteVault(int vaultId)
    {
        if (module == null || mapInstance == null) return;

        try
        {
            // Get the vault before deleting to store in undo history
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            var vaultToDelete = await Http.GetFromJsonAsync<Vault>($"api/vaults/{vaultId}", options);

            if (vaultToDelete == null)
            {
                await JS.InvokeVoidAsync("alert", "Vault not found.");
                return;
            }

            // Serialize the vault state for undo history
            string vaultJson = JsonSerializer.Serialize(vaultToDelete, options);

            // Call API to delete the vault
            var response = await Http.DeleteAsync($"api/vaults/{vaultId}");

            if (response.IsSuccessStatusCode)
            {
                // Add to undo history
                undoHistory.Push(new UndoHistoryEntry
                {
                    ActionType = UndoActionType.Delete,
                    EntityType = "vault",
                    EntityId = vaultId,
                    PreviousStateJson = vaultJson
                });

                // Limit history to 50 entries
                if (undoHistory.Count > 50)
                {
                    var tempStack = new Stack<UndoHistoryEntry>();
                    for (int i = 0; i < 50; i++)
                    {
                        tempStack.Push(undoHistory.Pop());
                    }
                    undoHistory = tempStack;
                }

                // Remove from map
                var layerKey = $"vault_{vaultId}";
                if (mapLayers.ContainsKey(layerKey))
                {
                    await module.InvokeVoidAsync("removeLayer", mapInstance, mapLayers[layerKey]);
                    mapLayers.Remove(layerKey);
                }

                // Refresh the vaults list
                await LoadVaults();
                
                // Refresh the map display
                StateHasChanged();
            }
            else
            {
                await JS.InvokeVoidAsync("alert", "Failed to delete vault. Please try again.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error deleting vault: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Failed to delete vault. Error: {ex.Message}");
        }
    }

    // Deletes a midpoint from the database and removes it from the map.
    // Also adds the deletion to the undo history so it can be undone.
    // <param name="midpointId">The unique ID of the midpoint to delete</param>
    private async Task DeleteMidpoint(int midpointId)
    {
        if (module == null || mapInstance == null) return;

        try
        {
            // Get the midpoint before deleting to store in undo history
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            var midpointToDelete = await Http.GetFromJsonAsync<Midpoint>($"api/midpoints/{midpointId}", options);

            if (midpointToDelete == null)
            {
                await JS.InvokeVoidAsync("alert", "Midpoint not found.");
                return;
            }

            // Serialize the midpoint state for undo history
            string midpointJson = JsonSerializer.Serialize(midpointToDelete, options);

            // Call API to delete the midpoint
            var response = await Http.DeleteAsync($"api/midpoints/{midpointId}");

            if (response.IsSuccessStatusCode)
            {
                // Add to undo history
                undoHistory.Push(new UndoHistoryEntry
                {
                    ActionType = UndoActionType.Delete,
                    EntityType = "midpoint",
                    EntityId = midpointId,
                    PreviousStateJson = midpointJson
                });

                // Limit history to 50 entries
                if (undoHistory.Count > 50)
                {
                    var tempStack = new Stack<UndoHistoryEntry>();
                    for (int i = 0; i < 50; i++)
                    {
                        tempStack.Push(undoHistory.Pop());
                    }
                    undoHistory = tempStack;
                }

                // Remove from map
                var layerKey = $"midpoint_{midpointId}";
                if (mapLayers.ContainsKey(layerKey))
                {
                    await module.InvokeVoidAsync("removeLayer", mapInstance, mapLayers[layerKey]);
                    mapLayers.Remove(layerKey);
                }

                // Refresh the midpoints list
                await LoadMidpoints();
                
                // Refresh the map display
                StateHasChanged();
            }
            else
            {
                await JS.InvokeVoidAsync("alert", "Failed to delete midpoint. Please try again.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error deleting midpoint: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Failed to delete midpoint. Error: {ex.Message}");
        }
    }

    // Deletes a cable from the database and removes it from the map, including all vertex markers.
    // Also adds the deletion to the undo history so it can be undone.
    // <param name="cableId">The unique ID of the cable to delete</param>
    private async Task DeleteCable(int cableId)
    {
        if (module == null || mapInstance == null) return;

        try
        {
            // Get the cable before deleting to store in undo history
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            var cableToDelete = await Http.GetFromJsonAsync<Cable>($"api/cables/{cableId}", options);

            if (cableToDelete == null)
            {
                await JS.InvokeVoidAsync("alert", "Cable not found.");
                return;
            }

            // Serialize the cable state for undo history
            string cableJson = JsonSerializer.Serialize(cableToDelete, options);

            // Call API to delete the cable
            var response = await Http.DeleteAsync($"api/cables/{cableId}");

            if (response.IsSuccessStatusCode)
            {
                // Add to undo history
                undoHistory.Push(new UndoHistoryEntry
                {
                    ActionType = UndoActionType.Delete,
                    EntityType = "cable",
                    EntityId = cableId,
                    PreviousStateJson = cableJson
                });

                // Limit history to 50 entries
                if (undoHistory.Count > 50)
                {
                    var tempStack = new Stack<UndoHistoryEntry>();
                    for (int i = 0; i < 50; i++)
                    {
                        tempStack.Push(undoHistory.Pop());
                    }
                    undoHistory = tempStack;
                }

                // Remove polyline from map
                var layerKey = $"cable_{cableId}";
                if (mapLayers.ContainsKey(layerKey))
                {
                    await module.InvokeVoidAsync("removeLayer", mapInstance, mapLayers[layerKey]);
                    mapLayers.Remove(layerKey);
                }
                
                // Remove all vertex markers for this cable
                if (cableVertexMarkers.ContainsKey(cableId))
                {
                    foreach (var vertexMarker in cableVertexMarkers[cableId])
                    {
                        await module.InvokeVoidAsync("removeLayer", mapInstance, vertexMarker);
                    }
                    cableVertexMarkers.Remove(cableId);
                }

                // Refresh the cables list
                await LoadCables();
                
                // Refresh the map display
                StateHasChanged();
            }
            else
            {
                await JS.InvokeVoidAsync("alert", "Failed to delete cable. Please try again.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error deleting cable: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Failed to delete cable. Error: {ex.Message}");
        }
    }

    // Gets the color name string based on the vault status.
    // Used to set the Color property when creating or updating vaults.
    // Maps status colors: New (blue), Pending (brown), Review (gray), Complete (green), Issue (red).
    // <param name="status">The vault status to get the color for</param>
    // <returns>A color name string (e.g., "Blue", "Brown", "Gray", "Green", "Red")</returns>
    private string GetStatusColor(VaultStatus status)
    {
        return status switch
        {
            VaultStatus.New => "Blue",
            VaultStatus.Pending => "Brown",
            VaultStatus.Review => "Gray",
            VaultStatus.Complete => "Green",
            VaultStatus.Issue => "Red",
            _ => "Blue" // Default to blue
        };
    }

    // Gets the color name string based on the midpoint status.
    // Used to set the Color property when creating or updating midpoints.
    // Maps status colors: New (black), Review (light gray), Complete (light green), Issue (light red).
    // <param name="status">The midpoint status to get the color for</param>
    // <returns>A color name string (e.g., "Black", "LightGray", "LightGreen", "LightCoral")</returns>
    private string GetMidpointStatusColor(MidpointStatus status)
    {
        return status switch
        {
            MidpointStatus.New => "Black",
            MidpointStatus.Review => "LightGray",
            MidpointStatus.Complete => "LightGreen",
            MidpointStatus.Issue => "LightCoral",
            _ => "Black" // Default to black
        };
    }

    // Updates a vault's location after it has been dragged to a new position on the map.
    // Also adds the move to the undo history so it can be undone.
    // <param name="vaultId">The unique ID of the vault to update</param>
    // <param name="newLat">The new latitude coordinate</param>
    // <param name="newLng">The new longitude coordinate</param>
    private async Task UpdateVaultLocation(int vaultId, double newLat, double newLng)
    {
        if (module == null || mapInstance == null) return;

        try
        {
            // First, get the current vault to preserve other properties and store previous state for undo
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            
            var vault = await Http.GetFromJsonAsync<Vault>($"api/vaults/{vaultId}", options);
            if (vault == null)
            {
                await JS.InvokeVoidAsync("alert", "Vault not found.");
                return;
            }

            // Store previous state for undo history
            string previousStateJson = JsonSerializer.Serialize(vault, options);

            // Create a new Point with the new coordinates (X=Longitude, Y=Latitude)
            var geometryFactory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
            var newLocation = geometryFactory.CreatePoint(new Coordinate(newLng, newLat));

            // Update the vault with the new location
            var updatedVault = new Vault
            {
                Id = vault.Id,
                Name = vault.Name,
                Status = vault.Status,
                Description = vault.Description,
                Color = vault.Color,
                Location = newLocation // Update the location
            };

            // Send PUT request to update the vault location
            var response = await Http.PutAsJsonAsync($"api/vaults/{vaultId}", updatedVault, options);

            if (response.IsSuccessStatusCode)
            {
                // Add to undo history
                undoHistory.Push(new UndoHistoryEntry
                {
                    ActionType = UndoActionType.Move,
                    EntityType = "vault",
                    EntityId = vaultId,
                    PreviousStateJson = previousStateJson
                });

                // Limit history to 50 entries
                if (undoHistory.Count > 50)
                {
                    var tempStack = new Stack<UndoHistoryEntry>();
                    for (int i = 0; i < 50; i++)
                    {
                        tempStack.Push(undoHistory.Pop());
                    }
                    undoHistory = tempStack;
                }

                // Load photos for this vault
                List<Photo>? vaultPhotos = null;
                try
                {
                    vaultPhotos = await Http.GetFromJsonAsync<List<Photo>>($"api/photos/vault/{vaultId}");
                }
                catch
                {
                    // If photos fail to load, continue without them
                }

                // Update the popup with new coordinates
                string descriptionText = string.IsNullOrWhiteSpace(updatedVault.Description) 
                    ? "No description provided." 
                    : System.Net.WebUtility.HtmlEncode(updatedVault.Description);
                string coordinates = $"{newLat:F6}, {newLng:F6}";
                string editButtonId = $"editVault_{vaultId}";
                string photosHtml = BuildPhotosHtml(vaultId, vaultPhotos, "vault");
                string newPopup = $"<div style='font-size: 12px; line-height: 1.6; width: 300px;'>" +
                    $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(updatedVault.Name)}<br>" +
                    photosHtml +
                    $"<strong>Status:</strong> {updatedVault.Status}<br>" +
                    $"<strong>Description:</strong> {descriptionText}<br>" +
                    $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                    $"<div style='margin-top: 8px;'>" +
                    $"<button id='{editButtonId}' class='btn btn-sm btn-primary me-2' style='font-size: 11px; padding: 2px 8px;'>Edit</button>" +
                    $"<a href='vault/{updatedVault.Id}' style='font-size: 11px;'>View Details</a>" +
                    $"</div>" +
                    $"</div>";
                
                // Update the marker's popup content
                var layerKey = $"vault_{vaultId}";
                if (mapLayers.ContainsKey(layerKey))
                {
                    await module.InvokeVoidAsync("updateMarkerPopup", mapLayers[layerKey], newPopup);
                    // Re-attach edit button handler after popup update
                    await module.InvokeVoidAsync("attachEditButtonHandler", mapLayers[layerKey], editButtonId, "vault", vaultId, dotNetReference);
                }

                // Refresh the vaults list to get updated data
                await LoadVaults();
            }
            else
            {
                var errorMessage = await response.Content.ReadAsStringAsync();
                await JS.InvokeVoidAsync("alert", $"Failed to update vault location: {errorMessage}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating vault location: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Error updating vault location: {ex.Message}");
        }
    }

    // Updates a midpoint's location after it has been dragged to a new position on the map.
    // Also adds the move to the undo history so it can be undone.
    // <param name="midpointId">The unique ID of the midpoint to update</param>
    // <param name="newLat">The new latitude coordinate</param>
    // <param name="newLng">The new longitude coordinate</param>
    private async Task UpdateMidpointLocation(int midpointId, double newLat, double newLng)
    {
        if (module == null || mapInstance == null) return;

        try
        {
            // First, get the current midpoint to preserve other properties and store previous state for undo
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            
            var midpoint = await Http.GetFromJsonAsync<Midpoint>($"api/midpoints/{midpointId}", options);
            if (midpoint == null)
            {
                await JS.InvokeVoidAsync("alert", "Midpoint not found.");
                return;
            }

            // Store previous state for undo history
            string previousStateJson = JsonSerializer.Serialize(midpoint, options);

            // Create a new Point with the new coordinates (X=Longitude, Y=Latitude)
            var geometryFactory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
            var newLocation = geometryFactory.CreatePoint(new Coordinate(newLng, newLat));

            // Update the midpoint with the new location
            var updatedMidpoint = new Midpoint
            {
                Id = midpoint.Id,
                Name = midpoint.Name,
                Status = midpoint.Status,
                Description = midpoint.Description,
                Color = midpoint.Color,
                Location = newLocation // Update the location
            };

            // Send PUT request to update the midpoint location
            var response = await Http.PutAsJsonAsync($"api/midpoints/{midpointId}", updatedMidpoint, options);

            if (response.IsSuccessStatusCode)
            {
                // Add to undo history
                undoHistory.Push(new UndoHistoryEntry
                {
                    ActionType = UndoActionType.Move,
                    EntityType = "midpoint",
                    EntityId = midpointId,
                    PreviousStateJson = previousStateJson
                });

                // Limit history to 50 entries
                if (undoHistory.Count > 50)
                {
                    var tempStack = new Stack<UndoHistoryEntry>();
                    for (int i = 0; i < 50; i++)
                    {
                        tempStack.Push(undoHistory.Pop());
                    }
                    undoHistory = tempStack;
                }

                // Load photos for this midpoint
                List<Photo>? midpointPhotos = null;
                try
                {
                    midpointPhotos = await Http.GetFromJsonAsync<List<Photo>>($"api/photos/midpoint/{midpointId}");
                }
                catch
                {
                    // If photos fail to load, continue without them
                }

                // Update the popup with new coordinates
                string descriptionText = string.IsNullOrWhiteSpace(updatedMidpoint.Description) 
                    ? "No description provided." 
                    : System.Net.WebUtility.HtmlEncode(updatedMidpoint.Description);
                string coordinates = $"{newLat:F6}, {newLng:F6}";
                string editButtonId = $"editMidpoint_{midpointId}";
                string photosHtml = BuildPhotosHtml(midpointId, midpointPhotos, "midpoint");
                string newPopup = $"<div style='font-size: 12px; line-height: 1.6; width: 300px;'>" +
                    $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(updatedMidpoint.Name)}<br>" +
                    photosHtml +
                    $"<strong>Status:</strong> {updatedMidpoint.Status}<br>" +
                    $"<strong>Description:</strong> {descriptionText}<br>" +
                    $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                    $"<div style='margin-top: 8px;'>" +
                    $"<button id='{editButtonId}' class='btn btn-sm btn-primary me-2' style='font-size: 11px; padding: 2px 8px;'>Edit</button>" +
                    $"<a href='midpoint/{updatedMidpoint.Id}' style='font-size: 11px;'>View Details</a>" +
                    $"</div>" +
                    $"</div>";
                
                // Update the marker's popup content
                var layerKey = $"midpoint_{midpointId}";
                if (mapLayers.ContainsKey(layerKey))
                {
                    await module.InvokeVoidAsync("updateMarkerPopup", mapLayers[layerKey], newPopup);
                    // Re-attach edit button handler after popup update
                    await module.InvokeVoidAsync("attachEditButtonHandler", mapLayers[layerKey], editButtonId, "midpoint", midpointId, dotNetReference);
                }

                // Refresh the midpoints list to get updated data
                await LoadMidpoints();
            }
            else
            {
                var errorMessage = await response.Content.ReadAsStringAsync();
                await JS.InvokeVoidAsync("alert", $"Failed to update midpoint location: {errorMessage}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating midpoint location: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Error updating midpoint location: {ex.Message}");
        }
    }

    // Calculates and formats the cable length for display in popups.
    // Uses the Haversine formula to calculate the great-circle distance between consecutive points,
    // then converts the result from meters to feet for display.
    // <param name="cable">The cable object containing the Path LineString</param>
    // <returns>A formatted string showing the length in feet</returns>
    private string GetCableLengthForPopup(Cable? cable)
    {
        if (cable?.Path == null || cable.Path.NumPoints < 2)
        {
            return "N/A";
        }

        double totalLengthMeters = 0.0;
        var coordinates = cable.Path.Coordinates;

        // Calculate distance between consecutive points using Haversine formula
        for (int i = 0; i < coordinates.Length - 1; i++)
        {
            var point1 = coordinates[i];
            var point2 = coordinates[i + 1];
            
            // Haversine formula to calculate distance between two lat/lng points
            double lat1 = point1.Y * Math.PI / 180.0; // Convert to radians
            double lat2 = point2.Y * Math.PI / 180.0;
            double deltaLat = (point2.Y - point1.Y) * Math.PI / 180.0;
            double deltaLng = (point2.X - point1.X) * Math.PI / 180.0;

            double a = Math.Sin(deltaLat / 2) * Math.Sin(deltaLat / 2) +
                       Math.Cos(lat1) * Math.Cos(lat2) *
                       Math.Sin(deltaLng / 2) * Math.Sin(deltaLng / 2);
            double c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
            
            // Earth's radius in meters (WGS84)
            const double earthRadiusMeters = 6371000.0;
            double distanceMeters = earthRadiusMeters * c;
            
            totalLengthMeters += distanceMeters;
        }

        // Convert meters to feet (1 meter = 3.28084 feet)
        const double metersToFeet = 3.28084;
        double totalLengthFeet = totalLengthMeters * metersToFeet;

        // Format the result for popup (shorter format)
        if (totalLengthFeet < 5280) // Less than 1 mile
        {
            return $"{totalLengthFeet:F1} ft";
        }
        else
        {
            // Display in miles for longer cables
            double miles = totalLengthFeet / 5280.0;
            return $"{miles:F2} mi";
        }
    }

    // Handles the Enter key press in the search input field.
    // Triggers the search when the user presses Enter.
    // <param name="e">Keyboard event arguments</param>
    private async Task HandleSearchKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !isSearching && !string.IsNullOrWhiteSpace(searchQuery))
        {
            await SearchLocation();
        }
    }

    // Searches for a location by address or coordinates and navigates the map to that location.
    // Supports two input formats:
    // 1. Street addresses (e.g., "123 Main St, San Antonio, TX") - uses Nominatim geocoding
    // 2. Coordinates (e.g., "29.54248, -98.73548" or "29.54248,-98.73548") - parses directly
    private async Task SearchLocation()
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            searchError = "Please enter an address or coordinates to search.";
            return;
        }

        isSearching = true;
        searchError = null;
        StateHasChanged();

        try
        {
            // Try to parse as coordinates first (format: "lat, lng" or "lat,lng")
            if (TryParseCoordinates(searchQuery, out double lat, out double lng))
            {
                // Valid coordinates - navigate directly
                await NavigateToLocation(lat, lng);
            }
            else
            {
                // Not coordinates - treat as address and geocode
                await GeocodeAddress(searchQuery);
            }
        }
        catch (Exception ex)
        {
            searchError = $"Search failed: {ex.Message}";
            Console.WriteLine($"Search error: {ex.Message}");
        }
        finally
        {
            isSearching = false;
            StateHasChanged();
        }
    }

    // Attempts to parse the search query as coordinates (latitude, longitude).
    // Supports formats like "29.54248, -98.73548" or "29.54248,-98.73548".
    // <param name="query">The search query to parse</param>
    // <param name="lat">Output parameter for the parsed latitude</param>
    // <param name="lng">Output parameter for the parsed longitude</param>
    // <returns>True if the query was successfully parsed as coordinates, false otherwise</returns>
    private bool TryParseCoordinates(string query, out double lat, out double lng)
    {
        lat = 0;
        lng = 0;

        // Remove whitespace and split by comma
        var parts = query.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        
        if (parts.Length == 2)
        {
            // Try to parse both parts as doubles
            if (double.TryParse(parts[0], out lat) && double.TryParse(parts[1], out lng))
            {
                // Validate coordinate ranges (latitude: -90 to 90, longitude: -180 to 180)
                if (lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180)
                {
                    return true;
                }
            }
        }

        return false;
    }

    // Geocodes an address using the Nominatim API (OpenStreetMap's geocoding service).
    // This converts a street address into latitude/longitude coordinates.
    // <param name="address">The address to geocode (e.g., "123 Main St, San Antonio, TX")</param>
    private async Task GeocodeAddress(string address)
    {
        try
        {
            // Use Nominatim (OpenStreetMap's geocoding service) - free, no API key required
            // Note: Nominatim has usage policies - be respectful with request frequency
            var encodedAddress = System.Net.WebUtility.UrlEncode(address);
            var nominatimUrl = $"https://nominatim.openstreetmap.org/search?q={encodedAddress}&format=json&limit=1";

            // Create HTTP request with proper headers (Nominatim requires a User-Agent)
            var request = new HttpRequestMessage(HttpMethod.Get, nominatimUrl);
            request.Headers.Add("User-Agent", "FOMSApp/1.0"); // Required by Nominatim usage policy

            var response = await Http.SendAsync(request);

            if (response.IsSuccessStatusCode)
            {
                var jsonContent = await response.Content.ReadAsStringAsync();
                var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                
                // Nominatim returns an array of results
                var results = JsonSerializer.Deserialize<JsonElement[]>(jsonContent, options);

                if (results != null && results.Length > 0)
                {
                    var firstResult = results[0];
                    
                    // Extract latitude and longitude from the result
                    if (firstResult.TryGetProperty("lat", out var latElement) &&
                        firstResult.TryGetProperty("lon", out var lngElement))
                    {
                        if (double.TryParse(latElement.GetString(), out double lat) &&
                            double.TryParse(lngElement.GetString(), out double lng))
                        {
                            await NavigateToLocation(lat, lng);
                            return;
                        }
                    }
                }

                searchError = "Address not found. Please try a more specific address or use coordinates.";
            }
            else
            {
                searchError = $"Geocoding service error: {response.StatusCode}";
            }
        }
        catch (Exception ex)
        {
            searchError = $"Failed to geocode address: {ex.Message}";
            Console.WriteLine($"Geocoding error: {ex.Message}");
        }
    }

    // Navigates the map to the specified location by panning and zooming.
    // <param name="lat">The target latitude</param>
    // <param name="lng">The target longitude</param>
    private async Task NavigateToLocation(double lat, double lng)
    {
        if (module == null || mapInstance == null)
        {
            searchError = "Map not initialized. Please wait for the map to load.";
            return;
        }

        try
        {
            // Call JavaScript function to pan and zoom the map to the location
            await module.InvokeVoidAsync("navigateToLocation", mapInstance, lat, lng);
            searchError = null; // Clear any previous errors
        }
        catch (Exception ex)
        {
            searchError = $"Failed to navigate to location: {ex.Message}";
            Console.WriteLine($"Navigation error: {ex.Message}");
        }
    }

    // Toggles between default map view and satellite view.
    private async Task ToggleMapView()
    {
        if (module == null || mapInstance == null)
        {
            return;
        }

        try
        {
            // Toggle the view state
            isSatelliteView = !isSatelliteView;

            // Call JavaScript function to switch map layers
            await module.InvokeVoidAsync("toggleMapView", mapInstance, isSatelliteView);

            // Trigger UI update to reflect button state change
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error toggling map view: {ex.Message}");
            // Revert state on error
            isSatelliteView = !isSatelliteView;
        }
    }

    // Handles when a cable vertex is dragged to a new location.
    // Updates the cable's path in the database and refreshes the display.
    // <param name="cableId">The ID of the cable being modified</param>
    // <param name="vertexIndex">The index of the vertex that was moved</param>
    // <param name="newLat">The new latitude of the vertex</param>
    // <param name="newLng">The new longitude of the vertex</param>
    [JSInvokable]
    public async Task OnCableVertexDragEnd(int cableId, int vertexIndex, double newLat, double newLng)
    {
        try
        {
            // Get the current cable and store previous state for undo
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            
            var cable = await Http.GetFromJsonAsync<Cable>($"api/cables/{cableId}", options);
            if (cable == null || cable.Path == null) return;

            // Store previous state for undo history
            string previousStateJson = JsonSerializer.Serialize(cable, options);

            // Update the coordinate at the specified index
            var coordinates = cable.Path.Coordinates.ToList();
            if (vertexIndex >= 0 && vertexIndex < coordinates.Count)
            {
                coordinates[vertexIndex] = new Coordinate(newLng, newLat);
                
                // Create new LineString with updated coordinates
                var factory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
                var newPath = factory.CreateLineString(coordinates.ToArray());
                
                // Update the cable
                cable.Path = newPath;
                
                // Send PUT request to update the cable path
                var response = await Http.PutAsJsonAsync($"api/cables/{cableId}", cable, options);
                
                if (response.IsSuccessStatusCode)
                {
                    // Add to undo history
                    undoHistory.Push(new UndoHistoryEntry
                    {
                        ActionType = UndoActionType.Move,
                        EntityType = "cable",
                        EntityId = cableId,
                        PreviousStateJson = previousStateJson
                    });

                    // Limit history to 50 entries
                    if (undoHistory.Count > 50)
                    {
                        var tempStack = new Stack<UndoHistoryEntry>();
                        for (int i = 0; i < 50; i++)
                        {
                            tempStack.Push(undoHistory.Pop());
                        }
                        undoHistory = tempStack;
                    }

                    // Reload the specific cable and redraw it with updated vertices
                    var updatedCable = await Http.GetFromJsonAsync<Cable>($"api/cables/{cableId}", options);
                    if (updatedCable != null)
                    {
                        // Preserve selection state
                        int? previousSelectedId = selectedCableId;
                        await DrawCableWithVertices(updatedCable);
                        selectedCableId = previousSelectedId;
                        StateHasChanged();
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating cable vertex: {ex.Message}");
        }
    }

    // Handles when a cable vertex drag operation starts.
    // Ensures the cable is selected so vertices remain visible during dragging.
    // <param name="cableId">The ID of the cable being edited</param>
    [JSInvokable]
    public async Task OnCableVertexDragStart(int cableId)
    {
        // Automatically select the cable when dragging starts so vertices stay visible
        if (selectedCableId != cableId)
        {
            // Hide vertices for previously selected cable
            if (selectedCableId.HasValue)
            {
                await HideCableVertices(selectedCableId.Value);
            }
            // Select the cable being edited
            selectedCableId = cableId;
            await ShowCableVertices(cableId);
        }
    }

    // Handles when a cable vertex drag operation completes.
    // Hides vertices if the cable is not selected.
    // <param name="cableId">The ID of the cable</param>
    [JSInvokable]
    public async Task OnCableVertexDragEndComplete(int cableId)
    {
        // Hide vertices if this cable is not currently selected
        // Note: If cable was auto-selected during drag, it will remain selected and vertices will stay visible
        if (selectedCableId != cableId)
        {
            await HideCableVertices(cableId);
        }
    }

    // Handles when a cable is selected (clicked).
    // Shows vertex markers for the selected cable and hides them for previously selected cable.
    // <param name="cableId">The ID of the cable that was selected</param>
    [JSInvokable]
    public async Task OnCableSelected(int cableId)
    {
        // Hide vertices for previously selected cable
        if (selectedCableId.HasValue && selectedCableId.Value != cableId)
        {
            await HideCableVertices(selectedCableId.Value);
        }

        // Toggle selection: if clicking the same cable, deselect it
        if (selectedCableId == cableId)
        {
            await HideCableVertices(cableId);
            selectedCableId = null;
        }
        else
        {
            // Show vertices for newly selected cable
            selectedCableId = cableId;
            await ShowCableVertices(cableId);
        }

        StateHasChanged();
    }

    // Handles when an entire cable is dragged to a new location.
    // Moves all vertices by the same offset.
    // <param name="cableId">The ID of the cable being moved</param>
    // <param name="deltaLat">The change in latitude</param>
    // <param name="deltaLng">The change in longitude</param>
    [JSInvokable]
    public async Task OnCableDragEnd(int cableId, double deltaLat, double deltaLng)
    {
        try
        {
            // Get the current cable and store previous state for undo
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            
            var cable = await Http.GetFromJsonAsync<Cable>($"api/cables/{cableId}", options);
            if (cable == null || cable.Path == null) return;

            // Store previous state for undo history
            string previousStateJson = JsonSerializer.Serialize(cable, options);

            // Update all coordinates by the delta
            var coordinates = cable.Path.Coordinates.Select(c => 
                new Coordinate(c.X + deltaLng, c.Y + deltaLat)).ToArray();
            
            // Create new LineString with updated coordinates
            var factory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
            var newPath = factory.CreateLineString(coordinates);
            
            // Update the cable
            cable.Path = newPath;
            
            // Send PUT request to update the cable path
            var response = await Http.PutAsJsonAsync($"api/cables/{cableId}", cable, options);
            
            if (response.IsSuccessStatusCode)
            {
                // Add to undo history
                undoHistory.Push(new UndoHistoryEntry
                {
                    ActionType = UndoActionType.Move,
                    EntityType = "cable",
                    EntityId = cableId,
                    PreviousStateJson = previousStateJson
                });

                // Limit history to 50 entries
                if (undoHistory.Count > 50)
                {
                    var tempStack = new Stack<UndoHistoryEntry>();
                    for (int i = 0; i < 50; i++)
                    {
                        tempStack.Push(undoHistory.Pop());
                    }
                    undoHistory = tempStack;
                }

                // Reload the cable and redraw it
                await LoadCables();
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error moving cable: {ex.Message}");
        }
    }

    // Opens the edit modal for a vault or midpoint.
    // <param name="entityType">The type of entity: "vault" or "midpoint"</param>
    // <param name="entityId">The ID of the entity to edit</param>
    [JSInvokable]
    public async Task OpenEditModal(string entityType, int entityId)
    {
        try
        {
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());

            if (entityType.ToLower() == "vault")
            {
                var vault = await Http.GetFromJsonAsync<Vault>($"api/vaults/{entityId}", options);
                if (vault != null)
                {
                    editingEntity = ("vault", entityId);
                    editingVaultModel = new VaultEditModel
                    {
                        Id = vault.Id,
                        Name = vault.Name ?? string.Empty,
                        Status = vault.Status,
                        Description = vault.Description ?? string.Empty
                    };
                    editingMidpointModel = null;
                    editingCableModel = null;
                }
            }
            else if (entityType.ToLower() == "midpoint")
            {
                var midpoint = await Http.GetFromJsonAsync<Midpoint>($"api/midpoints/{entityId}", options);
                if (midpoint != null)
                {
                    editingEntity = ("midpoint", entityId);
                    editingMidpointModel = new MidpointEditModel
                    {
                        Id = midpoint.Id,
                        Name = midpoint.Name ?? string.Empty,
                        Status = midpoint.Status,
                        Description = midpoint.Description ?? string.Empty
                    };
                    editingVaultModel = null;
                    editingCableModel = null;
                }
            }
            else if (entityType.ToLower() == "cable")
            {
                var cable = await Http.GetFromJsonAsync<Cable>($"api/cables/{entityId}", options);
                if (cable != null)
                {
                    editingEntity = ("cable", entityId);
                    editingCableModel = new CableEditModel
                    {
                        Id = cable.Id,
                        Name = cable.Name ?? string.Empty,
                        Description = cable.Description ?? string.Empty,
                        Color = cable.Color ?? "Black"
                    };
                    editingVaultModel = null;
                    editingMidpointModel = null;
                }
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error opening edit modal: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Failed to load {entityType} for editing. Error: {ex.Message}");
        }
    }

    // Closes the edit modal and clears the edit models.
    private void CloseEditModal()
    {
        editingEntity = null;
        editingVaultModel = null;
        editingMidpointModel = null;
        editingCableModel = null;
        isSavingEntity = false;
        StateHasChanged();
    }

    // Saves vault changes from the modal and updates the map popup.
    // Also adds the edit to the undo history so it can be undone.
    private async Task SaveVaultFromModal()
    {
        if (editingVaultModel == null || editingEntity == null || editingEntity.Value.Type != "vault")
            return;

        isSavingEntity = true;
        StateHasChanged();

        try
        {
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());

            // Get the current vault to preserve Location and store previous state for undo
            var currentVault = await Http.GetFromJsonAsync<Vault>($"api/vaults/{editingVaultModel.Id}", options);
            if (currentVault == null) return;

            // Store previous state for undo history
            string previousStateJson = JsonSerializer.Serialize(currentVault, options);

            // Update vault properties
            currentVault.Name = editingVaultModel.Name;
            currentVault.Status = editingVaultModel.Status;
            currentVault.Description = editingVaultModel.Description;

            // Send PUT request
            var response = await Http.PutAsJsonAsync($"api/vaults/{editingVaultModel.Id}", currentVault, options);

            if (response.IsSuccessStatusCode)
            {
                // Add to undo history
                undoHistory.Push(new UndoHistoryEntry
                {
                    ActionType = UndoActionType.Edit,
                    EntityType = "vault",
                    EntityId = editingVaultModel.Id,
                    PreviousStateJson = previousStateJson
                });

                // Limit history to 50 entries
                if (undoHistory.Count > 50)
                {
                    var tempStack = new Stack<UndoHistoryEntry>();
                    for (int i = 0; i < 50; i++)
                    {
                        tempStack.Push(undoHistory.Pop());
                    }
                    undoHistory = tempStack;
                }

                // Reload vaults to get updated data
                await LoadVaults();

                // Update the popup on the map
                await UpdateVaultPopup(editingVaultModel.Id);

                // Close modal
                CloseEditModal();
            }
            else
            {
                await JS.InvokeVoidAsync("alert", "Failed to save vault changes.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving vault: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Failed to save vault. Error: {ex.Message}");
        }
        finally
        {
            isSavingEntity = false;
            StateHasChanged();
        }
    }

    // Saves midpoint changes from the modal and updates the map popup.
    // Also adds the edit to the undo history so it can be undone.
    private async Task SaveMidpointFromModal()
    {
        if (editingMidpointModel == null || editingEntity == null || editingEntity.Value.Type != "midpoint")
            return;

        isSavingEntity = true;
        StateHasChanged();

        try
        {
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());

            // Get the current midpoint to preserve Location and store previous state for undo
            var currentMidpoint = await Http.GetFromJsonAsync<Midpoint>($"api/midpoints/{editingMidpointModel.Id}", options);
            if (currentMidpoint == null) return;

            // Store previous state for undo history
            string previousStateJson = JsonSerializer.Serialize(currentMidpoint, options);

            // Update midpoint properties
            currentMidpoint.Name = editingMidpointModel.Name;
            currentMidpoint.Status = editingMidpointModel.Status;
            currentMidpoint.Description = editingMidpointModel.Description;

            // Send PUT request
            var response = await Http.PutAsJsonAsync($"api/midpoints/{editingMidpointModel.Id}", currentMidpoint, options);

            if (response.IsSuccessStatusCode)
            {
                // Add to undo history
                undoHistory.Push(new UndoHistoryEntry
                {
                    ActionType = UndoActionType.Edit,
                    EntityType = "midpoint",
                    EntityId = editingMidpointModel.Id,
                    PreviousStateJson = previousStateJson
                });

                // Limit history to 50 entries
                if (undoHistory.Count > 50)
                {
                    var tempStack = new Stack<UndoHistoryEntry>();
                    for (int i = 0; i < 50; i++)
                    {
                        tempStack.Push(undoHistory.Pop());
                    }
                    undoHistory = tempStack;
                }

                // Reload midpoints to get updated data
                await LoadMidpoints();

                // Update the popup on the map
                await UpdateMidpointPopup(editingMidpointModel.Id);

                // Close modal
                CloseEditModal();
            }
            else
            {
                await JS.InvokeVoidAsync("alert", "Failed to save midpoint changes.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving midpoint: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Failed to save midpoint. Error: {ex.Message}");
        }
        finally
        {
            isSavingEntity = false;
            StateHasChanged();
        }
    }

    // Updates the popup content and marker color for a vault after editing.
    // <param name="vaultId">The ID of the vault to update</param>
    private async Task UpdateVaultPopup(int vaultId)
    {
        if (module == null || mapInstance == null || !mapLayers.ContainsKey($"vault_{vaultId}"))
            return;

        try
        {
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            var vault = await Http.GetFromJsonAsync<Vault>($"api/vaults/{vaultId}", options);

            if (vault != null && vault.Location != null)
            {
                // Load photos for this vault
                List<Photo>? vaultPhotos = null;
                try
                {
                    vaultPhotos = await Http.GetFromJsonAsync<List<Photo>>($"api/photos/vault/{vaultId}");
                }
                catch
                {
                    // If photos fail to load, continue without them
                }

                // Build updated popup content
                string descriptionText = string.IsNullOrWhiteSpace(vault.Description) 
                    ? "No description provided." 
                    : System.Net.WebUtility.HtmlEncode(vault.Description);
                string coordinates = $"{vault.Location.Y:F6}, {vault.Location.X:F6}";
                string editButtonId = $"editVault_{vault.Id}";
                string photosHtml = BuildPhotosHtml(vault.Id, vaultPhotos, "vault");
                
                string popup = $"<div style='font-size: 12px; line-height: 1.6; width: 300px;'>" +
                    $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(vault.Name)}<br>" +
                    photosHtml +
                    $"<strong>Status:</strong> {vault.Status}<br>" +
                    $"<strong>Description:</strong> {descriptionText}<br>" +
                    $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                    $"<div style='margin-top: 8px;'>" +
                    $"<button id='{editButtonId}' class='btn btn-sm btn-primary me-2' style='font-size: 11px; padding: 2px 8px;'>Edit</button>" +
                    $"<a href='vault/{vault.Id}' style='font-size: 11px;'>View Details</a>" +
                    $"</div>" +
                    $"</div>";
                
                // Get the updated color (API should have updated it based on status)
                string vaultColor = !string.IsNullOrWhiteSpace(vault.Color) ? vault.Color : GetStatusColor(vault.Status);
                bool isSelected = selectedVaultIds.Contains(vaultId);
                
                // Remove the old marker
                await module.InvokeVoidAsync("removeLayer", mapInstance, mapLayers[$"vault_{vaultId}"]);
                
                // Create a new marker with updated color and popup
                var newMarkerRef = await module.InvokeAsync<IJSObjectReference>("addMarker", mapInstance, vault.Location.Y, vault.Location.X, popup, vault.Id, dotNetReference, vaultColor, isSelected);
                mapLayers[$"vault_{vaultId}"] = newMarkerRef;
                
                // Attach edit button handler
                await module.InvokeVoidAsync("attachEditButtonHandler", newMarkerRef, editButtonId, "vault", vaultId, dotNetReference);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating vault popup: {ex.Message}");
        }
    }

    // Updates the marker visual state for a vault when selection changes.
    // Highlights the marker to show it's selected.
    // <param name="vaultId">The ID of the vault to update</param>
    private async Task UpdateVaultMarkerSelection(int vaultId)
    {
        if (module == null || mapInstance == null || !mapLayers.ContainsKey($"vault_{vaultId}"))
            return;

        try
        {
            bool isSelected = selectedVaultIds.Contains(vaultId);
            // Update the marker visual to show/hide selection highlight
            await module.InvokeVoidAsync("setMarkerSelection", mapLayers[$"vault_{vaultId}"], isSelected);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating vault marker selection: {ex.Message}");
        }
    }

    // Updates the marker visual state for a midpoint when selection changes.
    // Highlights the marker to show it's selected.
    // <param name="midpointId">The ID of the midpoint to update</param>
    private async Task UpdateMidpointMarkerSelection(int midpointId)
    {
        if (module == null || mapInstance == null || !mapLayers.ContainsKey($"midpoint_{midpointId}"))
            return;

        try
        {
            bool isSelected = selectedMidpointIds.Contains(midpointId);
            // Update the marker visual to show/hide selection highlight
            await module.InvokeVoidAsync("setCircleSelection", mapLayers[$"midpoint_{midpointId}"], isSelected);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating midpoint marker selection: {ex.Message}");
        }
    }

    // Clears all selections and updates marker visuals to remove highlighting.
    private async Task ClearAllSelections()
    {
        // Store the IDs before clearing so we can update their visuals
        var vaultIdsToUpdate = selectedVaultIds.ToList();
        var midpointIdsToUpdate = selectedMidpointIds.ToList();

        // Clear the selection sets
        selectedVaultIds.Clear();
        selectedMidpointIds.Clear();

        // Update marker visuals to remove highlighting
        foreach (var vaultId in vaultIdsToUpdate)
        {
            await UpdateVaultMarkerSelection(vaultId);
        }

        foreach (var midpointId in midpointIdsToUpdate)
        {
            await UpdateMidpointMarkerSelection(midpointId);
        }

        StateHasChanged();
    }

    // Downloads photos for all selected vaults and midpoints as a single ZIP file.
    // Each entity's photos are placed in a separate folder within the ZIP file.
    private async Task DownloadSelectedPhotos()
    {
        if (selectedVaultIds.Count == 0 && selectedMidpointIds.Count == 0)
        {
            await JS.InvokeVoidAsync("alert", "No items selected. Please select vaults or midpoints first.");
            return;
        }

        isDownloadingSelected = true;
        StateHasChanged();

        try
        {
            // Build query string with vault and midpoint IDs
            string vaultIdsParam = string.Join(",", selectedVaultIds);
            string midpointIdsParam = string.Join(",", selectedMidpointIds);
            
            // Build the URL with query parameters
            string url = "api/photos/batch-download";
            bool hasParams = false;
            
            if (!string.IsNullOrEmpty(vaultIdsParam))
            {
                url += $"?vaultIds={Uri.EscapeDataString(vaultIdsParam)}";
                hasParams = true;
            }
            
            if (!string.IsNullOrEmpty(midpointIdsParam))
            {
                url += hasParams ? "&" : "?";
                url += $"midpointIds={Uri.EscapeDataString(midpointIdsParam)}";
            }

            // Call the batch download endpoint
            var response = await Http.GetAsync(url);
            
            if (response.IsSuccessStatusCode)
            {
                var zipBytes = await response.Content.ReadAsByteArrayAsync();
                
                // Generate filename based on number of selected items
                int totalItems = selectedVaultIds.Count + selectedMidpointIds.Count;
                string fileName = totalItems == 1 
                    ? "Selected_Photos.zip" 
                    : $"Selected_Photos_{totalItems}_Items.zip";

                await JS.InvokeVoidAsync("downloadFile", fileName, Convert.ToBase64String(zipBytes));
                await JS.InvokeVoidAsync("alert", $"Successfully downloaded photos from {totalItems} item(s) in a single ZIP file.");
                
                // Clear selections after successful download
                await ClearAllSelections();
            }
            else
            {
                var errorMessage = await response.Content.ReadAsStringAsync();
                await JS.InvokeVoidAsync("alert", $"Failed to download photos: {errorMessage}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error downloading selected photos: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Error downloading photos: {ex.Message}");
        }
        finally
        {
            isDownloadingSelected = false;
            StateHasChanged();
        }
    }

    // Updates the popup content and marker color for a midpoint after editing.
    // <param name="midpointId">The ID of the midpoint to update</param>
    private async Task UpdateMidpointPopup(int midpointId)
    {
        if (module == null || mapInstance == null || !mapLayers.ContainsKey($"midpoint_{midpointId}"))
            return;

        try
        {
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            var midpoint = await Http.GetFromJsonAsync<Midpoint>($"api/midpoints/{midpointId}", options);

            if (midpoint != null && midpoint.Location != null)
            {
                // Load photos for this midpoint
                List<Photo>? midpointPhotos = null;
                try
                {
                    midpointPhotos = await Http.GetFromJsonAsync<List<Photo>>($"api/photos/midpoint/{midpointId}");
                }
                catch
                {
                    // If photos fail to load, continue without them
                }

                // Build updated popup content
                string descriptionText = string.IsNullOrWhiteSpace(midpoint.Description) 
                    ? "No description provided." 
                    : System.Net.WebUtility.HtmlEncode(midpoint.Description);
                string coordinates = $"{midpoint.Location.Y:F6}, {midpoint.Location.X:F6}";
                string editButtonId = $"editMidpoint_{midpointId}";
                string photosHtml = BuildPhotosHtml(midpointId, midpointPhotos, "midpoint");
                
                string popup = $"<div style='font-size: 12px; line-height: 1.6; width: 300px;'>" +
                    $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(midpoint.Name)}<br>" +
                    photosHtml +
                    $"<strong>Status:</strong> {midpoint.Status}<br>" +
                    $"<strong>Description:</strong> {descriptionText}<br>" +
                    $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                    $"<div style='margin-top: 8px;'>" +
                    $"<button id='{editButtonId}' class='btn btn-sm btn-primary me-2' style='font-size: 11px; padding: 2px 8px;'>Edit</button>" +
                    $"<a href='midpoint/{midpoint.Id}' style='font-size: 11px;'>View Details</a>" +
                    $"</div>" +
                    $"</div>";

                // Get the updated color (API should have updated it based on status)
                string midpointColor = !string.IsNullOrWhiteSpace(midpoint.Color) ? midpoint.Color : GetMidpointStatusColor(midpoint.Status);
                bool isSelected = selectedMidpointIds.Contains(midpointId);
                
                // Remove the old marker
                await module.InvokeVoidAsync("removeLayer", mapInstance, mapLayers[$"midpoint_{midpointId}"]);
                
                // Create a new marker with updated color and popup
                var newMarkerRef = await module.InvokeAsync<IJSObjectReference>("addCircle", mapInstance, midpoint.Location.Y, midpoint.Location.X, midpointColor, popup, midpoint.Id, dotNetReference, isSelected);
                mapLayers[$"midpoint_{midpointId}"] = newMarkerRef;
                
                // Attach edit button handler
                await module.InvokeVoidAsync("attachEditButtonHandler", newMarkerRef, editButtonId, "midpoint", midpointId, dotNetReference);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating midpoint popup: {ex.Message}");
        }
    }

    // Edit model for vault editing in the modal.
    private class VaultEditModel
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public VaultStatus Status { get; set; }
        public string? Description { get; set; }
    }

    // Edit model for midpoint editing in the modal.
    private class MidpointEditModel
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public MidpointStatus Status { get; set; }
        public string? Description { get; set; }
    }

    // Saves cable changes from the modal and updates the map popup and polyline color.
    // Also adds the edit to the undo history so it can be undone.
    private async Task SaveCableFromModal()
    {
        if (editingCableModel == null || editingEntity == null || editingEntity.Value.Type != "cable")
            return;

        isSavingEntity = true;
        StateHasChanged();

        try
        {
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());

            // Get the current cable to preserve Path and store previous state for undo
            var currentCable = await Http.GetFromJsonAsync<Cable>($"api/cables/{editingCableModel.Id}", options);
            if (currentCable == null) return;

            // Store previous state for undo history
            string previousStateJson = JsonSerializer.Serialize(currentCable, options);

            // Update cable properties
            currentCable.Name = editingCableModel.Name;
            currentCable.Description = editingCableModel.Description;
            currentCable.Color = editingCableModel.Color;

            // Send PUT request
            var response = await Http.PutAsJsonAsync($"api/cables/{editingCableModel.Id}", currentCable, options);

            if (response.IsSuccessStatusCode)
            {
                // Add to undo history
                undoHistory.Push(new UndoHistoryEntry
                {
                    ActionType = UndoActionType.Edit,
                    EntityType = "cable",
                    EntityId = editingCableModel.Id,
                    PreviousStateJson = previousStateJson
                });

                // Limit history to 50 entries
                if (undoHistory.Count > 50)
                {
                    var tempStack = new Stack<UndoHistoryEntry>();
                    for (int i = 0; i < 50; i++)
                    {
                        tempStack.Push(undoHistory.Pop());
                    }
                    undoHistory = tempStack;
                }

                // Reload cables to get updated data
                await LoadCables();

                // Update the cable on the map (this will update color and popup)
                await UpdateCablePopup(editingCableModel.Id);

                // Close modal
                CloseEditModal();
            }
            else
            {
                await JS.InvokeVoidAsync("alert", "Failed to save cable changes.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving cable: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Failed to save cable. Error: {ex.Message}");
        }
        finally
        {
            isSavingEntity = false;
            StateHasChanged();
        }
    }

    // Updates the cable polyline and popup after editing.
    // <param name="cableId">The ID of the cable to update</param>
    private async Task UpdateCablePopup(int cableId)
    {
        if (module == null || mapInstance == null || !mapLayers.ContainsKey($"cable_{cableId}"))
            return;

        try
        {
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            var cable = await Http.GetFromJsonAsync<Cable>($"api/cables/{cableId}", options);

            if (cable != null && cable.Path != null)
            {
                // Redraw the cable with updated properties (this updates color and popup)
                // Preserve selection state
                int? previousSelectedId = selectedCableId;
                await DrawCableWithVertices(cable);
                selectedCableId = previousSelectedId;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating cable popup: {ex.Message}");
        }
    }

    // Builds HTML for photo thumbnails with navigation in popups.
    // <param name="entityId">The ID of the entity (vault or midpoint)</param>
    // <param name="photos">List of photos for the entity</param>
    // <param name="entityType">Type of entity: "vault" or "midpoint"</param>
    // <returns>HTML string for photo thumbnails, or empty string if no photos</returns>
    private string BuildPhotosHtml(int entityId, List<Photo>? photos, string entityType)
    {
        if (photos == null || photos.Count == 0)
            return string.Empty;

        string photoContainerId = $"photos_{entityType}_{entityId}";
        string baseUrl = Http.BaseAddress?.ToString().TrimEnd('/') ?? "";
        string firstPhotoUrl = $"{baseUrl}/uploads/{System.Net.WebUtility.HtmlEncode(photos[0].FileName)}";
        
        // Build navigation buttons HTML - use single quotes in onclick to avoid conflicts with outer string
        string navButtons = "";
        if (photos.Count > 1)
        {
            navButtons = $"<div style='background-color: #333; color: white; padding: 4px 8px; display: flex; justify-content: space-between; align-items: center; font-size: 10px;'>" +
                $"<button id='prev_{photoContainerId}' onclick=\"navigatePhoto('{photoContainerId}', -1); return false;\" style='background: none; border: none; color: white; cursor: pointer; padding: 0 4px;'>&lt;</button>" +
                $"<span id='photoCount_{photoContainerId}'>1 of {photos.Count}</span>" +
                $"<button id='next_{photoContainerId}' onclick=\"navigatePhoto('{photoContainerId}', 1); return false;\" style='background: none; border: none; color: white; cursor: pointer; padding: 0 4px;'>&gt;</button>" +
                $"</div>";
        }
        else
        {
            navButtons = $"<div style='background-color: #333; color: white; padding: 4px 8px; text-align: center; font-size: 10px;'>" +
                $"<span>1 of 1</span>" +
                $"</div>";
        }

        // Build data attribute with all photo file names (stored as-is, not HTML encoded since it's in a data attribute)
        string photoUrls = string.Join(",", photos.Select(p => p.FileName ?? ""));
        
        // HTML encode the baseUrl for safety in the data attribute
        string encodedBaseUrl = System.Net.WebUtility.HtmlEncode(baseUrl);
        
        return $"<div id='{photoContainerId}' style='margin: 8px 0;' data-photos='{System.Net.WebUtility.HtmlEncode(photoUrls)}' data-current='0' data-baseurl='{encodedBaseUrl}/uploads/'>" +
            $"<img id='img_{photoContainerId}' src='{firstPhotoUrl}' style='width: 100%; max-width: 280px; height: auto; display: block; border: 1px solid #ddd;' alt='Photo 1 of {photos.Count}' />" +
            navButtons +
            $"</div>";
    }

    // Edit model for cable editing in the modal.
    private class CableEditModel
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public string? Description { get; set; }
        public string Color { get; set; } = "Black";
    }

    // Undoes the last action performed (delete, edit, or move) by restoring the previous state.
    private async Task UndoLastAction()
    {
        if (undoHistory.Count == 0 || module == null || mapInstance == null)
            return;

        try
        {
            // Pop the last action from the history stack
            var lastAction = undoHistory.Pop();
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());

            // Deserialize the previous state
            object? previousEntity = null;
            string entityType = lastAction.EntityType.ToLower();

            switch (entityType)
            {
                case "vault":
                    previousEntity = JsonSerializer.Deserialize<Vault>(lastAction.PreviousStateJson, options);
                    break;
                case "midpoint":
                    previousEntity = JsonSerializer.Deserialize<Midpoint>(lastAction.PreviousStateJson, options);
                    break;
                case "cable":
                    previousEntity = JsonSerializer.Deserialize<Cable>(lastAction.PreviousStateJson, options);
                    break;
            }

            if (previousEntity == null)
            {
                await JS.InvokeVoidAsync("alert", "Failed to restore previous state. Invalid data.");
                return;
            }

            // Restore based on action type
            switch (lastAction.ActionType)
            {
                case UndoActionType.Delete:
                    // Restore deleted entity by creating it again
                    if (previousEntity is Vault vault)
                    {
                        var vaultResponse = await Http.PostAsJsonAsync("api/vaults", vault, options);
                        if (vaultResponse.IsSuccessStatusCode)
                        {
                            // Read the created vault from the response to get the correct ID
                            var restoredVault = await vaultResponse.Content.ReadFromJsonAsync<Vault>(options);
                            if (restoredVault == null)
                            {
                                await JS.InvokeVoidAsync("alert", "Failed to restore vault. Invalid response.");
                                return;
                            }

                            await LoadVaults();
                            // Re-add vault to map using the same logic as OnAfterRenderAsync
                            if (restoredVault.Location != null)
                            {
                                List<Photo>? vaultPhotos = null;
                                try
                                {
                                    vaultPhotos = await Http.GetFromJsonAsync<List<Photo>>($"api/photos/vault/{restoredVault.Id}");
                                }
                                catch { }

                                string descriptionText = string.IsNullOrWhiteSpace(restoredVault.Description) 
                                    ? "No description provided." 
                                    : System.Net.WebUtility.HtmlEncode(restoredVault.Description);
                                string coordinates = $"{restoredVault.Location.Y:F6}, {restoredVault.Location.X:F6}";
                                string editButtonId = $"editVault_{restoredVault.Id}";
                                string photosHtml = BuildPhotosHtml(restoredVault.Id, vaultPhotos, "vault");
                                string popup = $"<div style='font-size: 12px; line-height: 1.6; width: 300px;'>" +
                                    $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(restoredVault.Name)}<br>" +
                                    photosHtml +
                                    $"<strong>Status:</strong> {restoredVault.Status}<br>" +
                                    $"<strong>Description:</strong> {descriptionText}<br>" +
                                    $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                                    $"<div style='margin-top: 8px;'>" +
                                    $"<button id='{editButtonId}' class='btn btn-sm btn-primary me-2' style='font-size: 11px; padding: 2px 8px;'>Edit</button>" +
                                    $"<a href='vault/{restoredVault.Id}' style='font-size: 11px;'>View Details</a>" +
                                    $"</div>" +
                                    $"</div>";
                                string vaultColor = !string.IsNullOrWhiteSpace(restoredVault.Color) ? restoredVault.Color : GetStatusColor(restoredVault.Status);
                                var markerRef = await module.InvokeAsync<IJSObjectReference>("addMarker", mapInstance, restoredVault.Location.Y, restoredVault.Location.X, popup, restoredVault.Id, dotNetReference, vaultColor);
                                mapLayers[$"vault_{restoredVault.Id}"] = markerRef;
                                await module.InvokeVoidAsync("attachEditButtonHandler", markerRef, editButtonId, "vault", restoredVault.Id, dotNetReference);
                            }
                        }
                        else
                        {
                            await JS.InvokeVoidAsync("alert", "Failed to restore vault.");
                        }
                    }
                    else if (previousEntity is Midpoint midpoint)
                    {
                        var midpointResponse = await Http.PostAsJsonAsync("api/midpoints", midpoint, options);
                        if (midpointResponse.IsSuccessStatusCode)
                        {
                            // Read the created midpoint from the response to get the correct ID
                            var restoredMidpoint = await midpointResponse.Content.ReadFromJsonAsync<Midpoint>(options);
                            if (restoredMidpoint == null)
                            {
                                await JS.InvokeVoidAsync("alert", "Failed to restore midpoint. Invalid response.");
                                return;
                            }

                            await LoadMidpoints();
                            // Re-add midpoint to map using the same logic as OnAfterRenderAsync
                            if (restoredMidpoint.Location != null)
                            {
                                List<Photo>? midpointPhotos = null;
                                try
                                {
                                    midpointPhotos = await Http.GetFromJsonAsync<List<Photo>>($"api/photos/midpoint/{restoredMidpoint.Id}");
                                }
                                catch { }

                                string descriptionText = string.IsNullOrWhiteSpace(restoredMidpoint.Description) 
                                    ? "No description provided." 
                                    : System.Net.WebUtility.HtmlEncode(restoredMidpoint.Description);
                                string coordinates = $"{restoredMidpoint.Location.Y:F6}, {restoredMidpoint.Location.X:F6}";
                                string editButtonId = $"editMidpoint_{restoredMidpoint.Id}";
                                string photosHtml = BuildPhotosHtml(restoredMidpoint.Id, midpointPhotos, "midpoint");
                                string popup = $"<div style='font-size: 12px; line-height: 1.6; width: 300px;'>" +
                                    $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(restoredMidpoint.Name)}<br>" +
                                    photosHtml +
                                    $"<strong>Status:</strong> {restoredMidpoint.Status}<br>" +
                                    $"<strong>Description:</strong> {descriptionText}<br>" +
                                    $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                                    $"<div style='margin-top: 8px;'>" +
                                    $"<button id='{editButtonId}' class='btn btn-sm btn-primary me-2' style='font-size: 11px; padding: 2px 8px;'>Edit</button>" +
                                    $"<a href='midpoint/{restoredMidpoint.Id}' style='font-size: 11px;'>View Details</a>" +
                                    $"</div>" +
                                    $"</div>";
                                string midpointColor = !string.IsNullOrWhiteSpace(restoredMidpoint.Color) ? restoredMidpoint.Color : GetMidpointStatusColor(restoredMidpoint.Status);
                                bool isSelected = selectedMidpointIds.Contains(restoredMidpoint.Id);
                                var circleRef = await module.InvokeAsync<IJSObjectReference>("addCircle", mapInstance, restoredMidpoint.Location.Y, restoredMidpoint.Location.X, midpointColor, popup, restoredMidpoint.Id, dotNetReference, isSelected);
                                mapLayers[$"midpoint_{restoredMidpoint.Id}"] = circleRef;
                                await module.InvokeVoidAsync("attachEditButtonHandler", circleRef, editButtonId, "midpoint", restoredMidpoint.Id, dotNetReference);
                            }
                        }
                        else
                        {
                            await JS.InvokeVoidAsync("alert", "Failed to restore midpoint.");
                        }
                    }
                    else if (previousEntity is Cable cable)
                    {
                        var cableResponse = await Http.PostAsJsonAsync("api/cables", cable, options);
                        if (cableResponse.IsSuccessStatusCode)
                        {
                            // Read the created cable from the response to get the correct ID
                            var restoredCable = await cableResponse.Content.ReadFromJsonAsync<Cable>(options);
                            if (restoredCable == null)
                            {
                                await JS.InvokeVoidAsync("alert", "Failed to restore cable. Invalid response.");
                                return;
                            }

                            await LoadCables();
                            // Re-add cable to map
                            if (restoredCable.Path != null)
                            {
                                await DrawCableWithVertices(restoredCable);
                            }
                        }
                        else
                        {
                            await JS.InvokeVoidAsync("alert", "Failed to restore cable.");
                        }
                    }
                    break;

                case UndoActionType.Edit:
                case UndoActionType.Move:
                    // Restore previous state by updating the entity
                    if (previousEntity is Vault vaultToRestore)
                    {
                        var vaultPutResponse = await Http.PutAsJsonAsync($"api/vaults/{vaultToRestore.Id}", vaultToRestore, options);
                        if (vaultPutResponse.IsSuccessStatusCode)
                        {
                            await LoadVaults();
                            await UpdateVaultPopup(vaultToRestore.Id);
                        }
                        else
                        {
                            await JS.InvokeVoidAsync("alert", "Failed to restore vault state.");
                        }
                    }
                    else if (previousEntity is Midpoint midpointToRestore)
                    {
                        var midpointPutResponse = await Http.PutAsJsonAsync($"api/midpoints/{midpointToRestore.Id}", midpointToRestore, options);
                        if (midpointPutResponse.IsSuccessStatusCode)
                        {
                            await LoadMidpoints();
                            await UpdateMidpointPopup(midpointToRestore.Id);
                        }
                        else
                        {
                            await JS.InvokeVoidAsync("alert", "Failed to restore midpoint state.");
                        }
                    }
                    else if (previousEntity is Cable cableToRestore)
                    {
                        var cablePutResponse = await Http.PutAsJsonAsync($"api/cables/{cableToRestore.Id}", cableToRestore, options);
                        if (cablePutResponse.IsSuccessStatusCode)
                        {
                            await LoadCables();
                            await UpdateCablePopup(cableToRestore.Id);
                        }
                        else
                        {
                            await JS.InvokeVoidAsync("alert", "Failed to restore cable state.");
                        }
                    }
                    break;
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error undoing action: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Failed to undo action. Error: {ex.Message}");
        }
    }

    // Cleanup method to dispose of resources when the component is destroyed.
    // Prevents memory leaks by disposing the DotNetObjectReference.
    public void Dispose()
    {
        dotNetReference?.Dispose();
    }
}
