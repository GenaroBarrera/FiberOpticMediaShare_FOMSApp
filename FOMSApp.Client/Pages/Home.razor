@page "/"
@using FOMSApp.Shared.Models
@using Microsoft.JSInterop
@using System.Text.Json
@using NetTopologySuite.IO.Converters
@using NetTopologySuite.Geometries
@using NetTopologySuite
@inject HttpClient Http
@inject IJSRuntime JS

<PageTitle>Fiber Map</PageTitle>

<h1>Fiber Network Map</h1>

@if (vaults == null || midpoints == null || cables == null)
{
    <p><em>Loading network data...</em></p>
}
else
{
    <!-- Toolbar for map editing modes -->
    <div class="btn-toolbar mb-3" role="toolbar">
        <div class="btn-group me-2" role="group">
            <button type="button" 
                    class="btn @(currentMode == MapMode.View ? "btn-primary" : "btn-outline-primary")"
                    @onclick="async () => await SetMode(MapMode.View)">
                View
            </button>
            <button type="button" 
                    class="btn @(currentMode == MapMode.AddVault ? "btn-primary" : "btn-outline-primary")"
                    @onclick="async () => await SetMode(MapMode.AddVault)">
                Add Vault
            </button>
            <button type="button" 
                    class="btn @(currentMode == MapMode.AddMidpoint ? "btn-primary" : "btn-outline-primary")"
                    @onclick="async () => await SetMode(MapMode.AddMidpoint)">
                Add Midpoint
            </button>
            <button type="button" 
                    class="btn @(currentMode == MapMode.DrawCable ? "btn-primary" : "btn-outline-primary")"
                    @onclick="async () => await SetMode(MapMode.DrawCable)">
                Draw Cable
            </button>
            <button type="button" 
                    class="btn @(currentMode == MapMode.Delete ? "btn-primary" : "btn-outline-primary")"
                    @onclick="async () => await SetMode(MapMode.Delete)">
                Delete
            </button>
        </div>
    </div>

    <!-- Status message for current mode -->
    @if (currentMode != MapMode.View)
    {
        <div class="alert alert-info" role="alert">
            @GetModeInstructions()
        </div>
    }

    <!-- Cable drawing progress indicator -->
    @if (currentMode == MapMode.DrawCable && cablePoints.Count > 0)
    {
        <div class="alert alert-warning" role="alert">
            Cable drawing in progress: @cablePoints.Count point(s) added. Click "Finish Cable" to save or "Cancel" to start over.
            <button type="button" class="btn btn-sm btn-success ms-2" @onclick="FinishCable">Finish Cable</button>
            <button type="button" class="btn btn-sm btn-danger ms-2" @onclick="CancelCable">Cancel</button>
        </div>
    }

    <div id="map" class="map-container"></div>
}

@implements IDisposable

@code {
    /// <summary>
    /// Enumeration defining the different interaction modes for the map editor.
    /// </summary>
    private enum MapMode
    {
        View,           // Default mode - no editing, just viewing
        AddVault,       // Click on map to create a new vault
        AddMidpoint,    // Click on map to create a new midpoint
        DrawCable,      // Click multiple points to define a cable path
        Delete          // Click on existing items to delete them
    }

    private Vault[]? vaults;
    private Midpoint[]? midpoints;
    private Cable[]? cables;
    
    private IJSObjectReference? module;
    private IJSObjectReference? mapInstance;
    
    /// <summary>
    /// Current interaction mode for the map editor.
    /// </summary>
    private MapMode currentMode = MapMode.View;
    
    /// <summary>
    /// Temporary storage for points collected while drawing a cable.
    /// </summary>
    private List<(double Lat, double Lng)> cablePoints = new();
    
    /// <summary>
    /// Temporary polyline reference for previewing the cable being drawn.
    /// </summary>
    private IJSObjectReference? tempCablePolyline;

    /// <summary>
    /// Dictionary to store map layer references (markers, circles, polylines) with their entity IDs.
    /// Used to identify which item was clicked for deletion.
    /// Key: Entity ID (vault/midpoint/cable ID), Value: JavaScript object reference to the Leaflet layer
    /// </summary>
    private Dictionary<string, IJSObjectReference> mapLayers = new();

    /// <summary>
    /// .NET object reference for JavaScript interop callbacks.
    /// Used to allow JavaScript to call back into C# methods (e.g., for delete functionality).
    /// </summary>
    private DotNetObjectReference<Home>? dotNetReference;

    protected override async Task OnInitializedAsync()
    {
        try 
        {
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());

            // Fetch all three data types
            vaults = await Http.GetFromJsonAsync<Vault[]>("api/vaults", options);
            midpoints = await Http.GetFromJsonAsync<Midpoint[]>("api/midpoints", options);
            cables = await Http.GetFromJsonAsync<Cable[]>("api/cables", options);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"DATA FETCH ERROR: {ex.Message}");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (mapInstance == null && vaults != null && midpoints != null && cables != null)
        {
            try 
            {
                module = await JS.InvokeAsync<IJSObjectReference>("import", "./mapHelper.js");
                mapInstance = await module.InvokeAsync<IJSObjectReference>("initMap", "map");

                // Setup click event listener for map interactions (needed for delete mode)
                dotNetReference = DotNetObjectReference.Create(this);
                await SetupMapClickListener();
                
                // Initialize delete mode state in JavaScript
                await module.InvokeVoidAsync("setDeleteMode", currentMode == MapMode.Delete);

                // 1. Draw VAULTS (Pins) - Store layer references for deletion
                foreach (var vault in vaults)
                {
                    if (vault.Location != null)
                    {
                        string popup = $"<b>{vault.Name}</b><br>{vault.Status}<br><a href='vault/{vault.Id}'>View Details</a>";
                        var markerRef = await module.InvokeAsync<IJSObjectReference>("addMarker", mapInstance, vault.Location.Y, vault.Location.X, popup, vault.Id, dotNetReference);
                        mapLayers[$"vault_{vault.Id}"] = markerRef;
                    }
                }

                // 2. Draw MIDPOINTS (Dots) - Store layer references for deletion
                foreach (var mp in midpoints)
                {
                    if (mp.Location != null)
                    {
                        var circleRef = await module.InvokeAsync<IJSObjectReference>("addCircle", mapInstance, mp.Location.Y, mp.Location.X, mp.Color, $"<b>{mp.Name}</b>", mp.Id, dotNetReference);
                        mapLayers[$"midpoint_{mp.Id}"] = circleRef;
                    }
                }

                // 3. Draw CABLES (Lines) - Store layer references for deletion
                foreach (var cable in cables)
                {
                    if (cable.Path != null)
                    {
                        // Convert NetTopologySuite points (Lng/Lat) to Leaflet objects (Lat/Lng)
                        var latLngs = new List<object>();
                        foreach (var coord in cable.Path.Coordinates)
                        {
                            latLngs.Add(new { lat = coord.Y, lng = coord.X });
                        }

                        // Call the JS function and store the reference
                        var polylineRef = await module.InvokeAsync<IJSObjectReference>("addPolyline", mapInstance, latLngs, cable.Color, $"<b>{cable.Name}</b>", cable.Id, dotNetReference);
                        mapLayers[$"cable_{cable.Id}"] = polylineRef;
                    }
                }
            }
            catch(Exception ex)
            {
                Console.WriteLine($"MAP RENDER ERROR: {ex.Message}");
            }
        }
    }

    /// <summary>
    /// Sets up the click event listener on the map to handle user interactions based on the current mode.
    /// </summary>
    private async Task SetupMapClickListener()
    {
        if (module != null && mapInstance != null)
        {
            // Register a callback that will be invoked from JavaScript when the map is clicked
            var dotNetReference = DotNetObjectReference.Create(this);
            await module.InvokeVoidAsync("addClickEventListener", mapInstance, dotNetReference);
        }
    }

    /// <summary>
    /// Handles clicks on map entities (vaults, midpoints, cables) when in Delete mode.
    /// This method is called from JavaScript when a user clicks on a marker, circle, or polyline.
    /// </summary>
    /// <param name="entityType">The type of entity clicked: "vault", "midpoint", or "cable"</param>
    /// <param name="entityId">The unique ID of the entity to delete</param>
    [JSInvokable]
    public async Task OnEntityClick(string entityType, int entityId)
    {
        // Log for debugging
        Console.WriteLine($"OnEntityClick called: type={entityType}, id={entityId}, currentMode={currentMode}");
        
        // Only handle deletion if we're in Delete mode
        if (currentMode != MapMode.Delete)
        {
            Console.WriteLine($"Not in delete mode, ignoring click. Current mode: {currentMode}");
            return;
        }

        try
        {
            // Show confirmation dialog
            var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to delete this {entityType}?");
            if (!confirmed)
            {
                return;
            }

            // Delete based on entity type
            switch (entityType.ToLower())
            {
                case "vault":
                    await DeleteVault(entityId);
                    break;
                case "midpoint":
                    await DeleteMidpoint(entityId);
                    break;
                case "cable":
                    await DeleteCable(entityId);
                    break;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ERROR deleting {entityType}: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Failed to delete {entityType}. Error: {ex.Message}");
        }
    }

    /// <summary>
    /// Handles map click events from JavaScript. This method is called via JSInterop when the user clicks on the map.
    /// </summary>
    /// <param name="lat">Latitude of the click location.</param>
    /// <param name="lng">Longitude of the click location.</param>
    [JSInvokable]
    public async Task OnMapClick(double lat, double lng)
    {
        if (currentMode == MapMode.View)
        {
            // In view mode, clicks don't do anything
            return;
        }

        try
        {
            switch (currentMode)
            {
                case MapMode.AddVault:
                    await CreateVaultAtLocation(lat, lng);
                    break;

                case MapMode.AddMidpoint:
                    await CreateMidpointAtLocation(lat, lng);
                    break;

                case MapMode.DrawCable:
                    await AddCablePoint(lat, lng);
                    break;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ERROR handling map click: {ex.Message}");
        }

        // Trigger UI update
        StateHasChanged();
    }

    /// <summary>
    /// Changes the current map interaction mode and provides user feedback.
    /// </summary>
    /// <param name="mode">The mode to switch to.</param>
    private async Task SetMode(MapMode mode)
    {
        // If switching away from DrawCable mode, cancel any in-progress cable
        if (currentMode == MapMode.DrawCable && mode != MapMode.DrawCable)
        {
            await CancelCable();
        }

        currentMode = mode;

        // Update JavaScript delete mode state so click handlers know the current mode
        if (module != null)
        {
            await module.InvokeVoidAsync("setDeleteMode", mode == MapMode.Delete);
        }
    }

    /// <summary>
    /// Returns user-friendly instructions for the current map mode.
    /// </summary>
    private string GetModeInstructions()
    {
        return currentMode switch
        {
            MapMode.AddVault => "Click on the map to add a new vault at that location.",
            MapMode.AddMidpoint => "Click on the map to add a new midpoint at that location.",
            MapMode.DrawCable => "Click multiple points on the map to define the cable path. Click 'Finish Cable' when done.",
            MapMode.Delete => "Click on a vault, midpoint, or cable to delete it.",
            _ => ""
        };
    }

    /// <summary>
    /// Creates a new vault at the specified geographic coordinates.
    /// </summary>
    /// <param name="lat">Latitude of the vault location.</param>
    /// <param name="lng">Longitude of the vault location.</param>
    private async Task CreateVaultAtLocation(double lat, double lng)
    {
        if (module == null || mapInstance == null) return;

        // Prompt user for vault name
        var vaultName = await JS.InvokeAsync<string>("prompt", "Enter vault name:");
        if (string.IsNullOrWhiteSpace(vaultName))
        {
            return; // User cancelled
        }

        // Create Point geometry (NetTopologySuite uses X for Longitude, Y for Latitude)
        // SRID 4326 is the standard for GPS (WGS 84)
        var factory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
        var location = factory.CreatePoint(new Coordinate(lng, lat));

        // Create the vault object
        var newVault = new Vault
        {
            Name = vaultName,
            Location = location,
            Status = VaultStatus.Pending,
            Color = "Blue"
        };

        // Serialize with GeoJSON support
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());

        // POST to API
        var response = await Http.PostAsJsonAsync("api/vaults", newVault, options);
        
        if (response.IsSuccessStatusCode)
        {
            var createdVault = await response.Content.ReadFromJsonAsync<Vault>(options);
            
            if (createdVault != null && createdVault.Location != null && dotNetReference != null)
            {
                // Add marker to map immediately and store reference for deletion
                string popup = $"<b>{createdVault.Name}</b><br>{createdVault.Status}<br><a href='vault/{createdVault.Id}'>View Details</a>";
                var markerRef = await module.InvokeAsync<IJSObjectReference>("addMarker", mapInstance, createdVault.Location.Y, createdVault.Location.X, popup, createdVault.Id, dotNetReference);
                mapLayers[$"vault_{createdVault.Id}"] = markerRef;

                // Refresh the vaults list
                await LoadVaults();
            }
        }
    }

    /// <summary>
    /// Creates a new midpoint at the specified geographic coordinates.
    /// </summary>
    /// <param name="lat">Latitude of the midpoint location.</param>
    /// <param name="lng">Longitude of the midpoint location.</param>
    private async Task CreateMidpointAtLocation(double lat, double lng)
    {
        if (module == null || mapInstance == null) return;

        // Prompt user for midpoint name
        var midpointName = await JS.InvokeAsync<string>("prompt", "Enter midpoint name:");
        if (string.IsNullOrWhiteSpace(midpointName))
        {
            return; // User cancelled
        }

        // Create Point geometry
        // SRID 4326 is the standard for GPS (WGS 84)
        var factory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
        var location = factory.CreatePoint(new Coordinate(lng, lat));

        // Create the midpoint object
        var newMidpoint = new Midpoint
        {
            Name = midpointName,
            Location = location,
            Color = "Green"
        };

        // Serialize with GeoJSON support
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());

        // POST to API
        var response = await Http.PostAsJsonAsync("api/midpoints", newMidpoint, options);
        
        if (response.IsSuccessStatusCode)
        {
            var createdMidpoint = await response.Content.ReadFromJsonAsync<Midpoint>(options);
            
            if (createdMidpoint != null && createdMidpoint.Location != null && dotNetReference != null)
            {
                // Add circle to map immediately and store reference for deletion
                var circleRef = await module.InvokeAsync<IJSObjectReference>("addCircle", mapInstance, createdMidpoint.Location.Y, createdMidpoint.Location.X, createdMidpoint.Color, $"<b>{createdMidpoint.Name}</b>", createdMidpoint.Id, dotNetReference);
                mapLayers[$"midpoint_{createdMidpoint.Id}"] = circleRef;

                // Refresh the midpoints list
                await LoadMidpoints();
            }
        }
    }

    /// <summary>
    /// Adds a point to the current cable being drawn and updates the preview polyline.
    /// </summary>
    /// <param name="lat">Latitude of the point.</param>
    /// <param name="lng">Longitude of the point.</param>
    private async Task AddCablePoint(double lat, double lng)
    {
        if (module == null || mapInstance == null) return;

        // Add point to collection
        cablePoints.Add((lat, lng));

        // If we have at least 2 points, draw/update the preview polyline
        if (cablePoints.Count >= 2)
        {
            // Remove previous preview if it exists
            if (tempCablePolyline != null)
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, tempCablePolyline);
            }

            // Create array of coordinates for the preview
            var latLngs = cablePoints.Select(p => new { lat = p.Lat, lng = p.Lng }).ToList<object>();
            
            // Draw preview polyline in orange
            tempCablePolyline = await module.InvokeAsync<IJSObjectReference>("addPolyline", mapInstance, latLngs, "Orange", "Preview - Click 'Finish Cable' to save");
        }
        else if (cablePoints.Count == 1)
        {
            // Show first point as a marker
            await module.InvokeVoidAsync("addMarker", mapInstance, lat, lng, "Start point - Click more points to draw cable");
        }
    }

    /// <summary>
    /// Completes the cable drawing by saving the collected points as a LineString to the database.
    /// </summary>
    private async Task FinishCable()
    {
        if (cablePoints.Count < 2)
        {
            await JS.InvokeVoidAsync("alert", "A cable needs at least 2 points. Please add more points before finishing.");
            return;
        }

        // Prompt user for cable name
        var cableName = await JS.InvokeAsync<string>("prompt", "Enter cable name:");
        if (string.IsNullOrWhiteSpace(cableName))
        {
            return; // User cancelled
        }

        // Create LineString from collected points (NetTopologySuite uses X for Longitude, Y for Latitude)
        // SRID 4326 is the standard for GPS (WGS 84)
        var factory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
        var coordinates = cablePoints.Select(p => new Coordinate(p.Lng, p.Lat)).ToArray();
        var lineString = factory.CreateLineString(coordinates);

        // Create the cable object
        var newCable = new Cable
        {
            Name = cableName,
            Path = lineString,
            Color = "Orange"
        };

        // Serialize with GeoJSON support
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());

        // POST to API
        var response = await Http.PostAsJsonAsync("api/cables", newCable, options);
        
        if (response.IsSuccessStatusCode)
        {
            var createdCable = await response.Content.ReadFromJsonAsync<Cable>(options);
            
            if (createdCable != null && createdCable.Path != null && module != null && mapInstance != null)
            {
                // Remove preview polyline
                if (tempCablePolyline != null)
                {
                    await module.InvokeVoidAsync("removeLayer", mapInstance, tempCablePolyline);
                    tempCablePolyline = null;
                }

                // Draw the saved cable and store reference for deletion
                var latLngs = new List<object>();
                foreach (var coord in createdCable.Path.Coordinates)
                {
                    latLngs.Add(new { lat = coord.Y, lng = coord.X });
                }
                if (dotNetReference != null)
                {
                    var polylineRef = await module.InvokeAsync<IJSObjectReference>("addPolyline", mapInstance, latLngs, createdCable.Color, $"<b>{createdCable.Name}</b>", createdCable.Id, dotNetReference);
                    mapLayers[$"cable_{createdCable.Id}"] = polylineRef;
                }

                // Refresh the cables list
                await LoadCables();
            }

            // Reset cable drawing state
            cablePoints.Clear();
            currentMode = MapMode.View;
        }
    }

    /// <summary>
    /// Cancels the current cable drawing operation and clears the preview.
    /// </summary>
    private async Task CancelCable()
    {
        if (module != null && mapInstance != null && tempCablePolyline != null)
        {
            await module.InvokeVoidAsync("removeLayer", mapInstance, tempCablePolyline);
            tempCablePolyline = null;
        }
        cablePoints.Clear();
        currentMode = MapMode.View;
    }

    /// <summary>
    /// Reloads the vaults from the API and refreshes the display.
    /// </summary>
    private async Task LoadVaults()
    {
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());
        vaults = await Http.GetFromJsonAsync<Vault[]>("api/vaults", options);
    }

    /// <summary>
    /// Reloads the midpoints from the API and refreshes the display.
    /// </summary>
    private async Task LoadMidpoints()
    {
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());
        midpoints = await Http.GetFromJsonAsync<Midpoint[]>("api/midpoints", options);
    }

    /// <summary>
    /// Reloads the cables from the API and refreshes the display.
    /// </summary>
    private async Task LoadCables()
    {
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());
        cables = await Http.GetFromJsonAsync<Cable[]>("api/cables", options);
    }

    /// <summary>
    /// Deletes a vault from the database and removes it from the map.
    /// </summary>
    /// <param name="vaultId">The unique ID of the vault to delete</param>
    private async Task DeleteVault(int vaultId)
    {
        if (module == null || mapInstance == null) return;

        // Call API to delete the vault
        var response = await Http.DeleteAsync($"api/vaults/{vaultId}");

        if (response.IsSuccessStatusCode)
        {
            // Remove from map
            var layerKey = $"vault_{vaultId}";
            if (mapLayers.ContainsKey(layerKey))
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, mapLayers[layerKey]);
                mapLayers.Remove(layerKey);
            }

            // Refresh the vaults list
            await LoadVaults();
            
            // Refresh the map display
            StateHasChanged();
        }
        else
        {
            await JS.InvokeVoidAsync("alert", "Failed to delete vault. Please try again.");
        }
    }

    /// <summary>
    /// Deletes a midpoint from the database and removes it from the map.
    /// </summary>
    /// <param name="midpointId">The unique ID of the midpoint to delete</param>
    private async Task DeleteMidpoint(int midpointId)
    {
        if (module == null || mapInstance == null) return;

        // Call API to delete the midpoint
        var response = await Http.DeleteAsync($"api/midpoints/{midpointId}");

        if (response.IsSuccessStatusCode)
        {
            // Remove from map
            var layerKey = $"midpoint_{midpointId}";
            if (mapLayers.ContainsKey(layerKey))
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, mapLayers[layerKey]);
                mapLayers.Remove(layerKey);
            }

            // Refresh the midpoints list
            await LoadMidpoints();
            
            // Refresh the map display
            StateHasChanged();
        }
        else
        {
            await JS.InvokeVoidAsync("alert", "Failed to delete midpoint. Please try again.");
        }
    }

    /// <summary>
    /// Deletes a cable from the database and removes it from the map.
    /// </summary>
    /// <param name="cableId">The unique ID of the cable to delete</param>
    private async Task DeleteCable(int cableId)
    {
        if (module == null || mapInstance == null) return;

        // Call API to delete the cable
        var response = await Http.DeleteAsync($"api/cables/{cableId}");

        if (response.IsSuccessStatusCode)
        {
            // Remove from map
            var layerKey = $"cable_{cableId}";
            if (mapLayers.ContainsKey(layerKey))
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, mapLayers[layerKey]);
                mapLayers.Remove(layerKey);
            }

            // Refresh the cables list
            await LoadCables();
            
            // Refresh the map display
            StateHasChanged();
        }
        else
        {
            await JS.InvokeVoidAsync("alert", "Failed to delete cable. Please try again.");
        }
    }

    /// <summary>
    /// Cleanup method to dispose of resources when the component is destroyed.
    /// Prevents memory leaks by disposing the DotNetObjectReference.
    /// </summary>
    public void Dispose()
    {
        dotNetReference?.Dispose();
    }
}