@page "/"
@using FOMSApp.Shared.Models
@using Microsoft.JSInterop
@using System.Text.Json
@using System.Net
@using NetTopologySuite.IO.Converters
@using NetTopologySuite.Geometries
@using NetTopologySuite
@using System.Linq
@inject HttpClient Http
@inject IJSRuntime JS

<PageTitle>Fiber Map</PageTitle>

<h1>Fiber Network Map</h1>

@if (vaults == null || midpoints == null || cables == null)
{
    <p><em>Loading network data...</em></p>
}
else
{
    <!-- Search Bar -->
    <div class="mb-3">
        <div class="input-group">
            <input type="text" 
                   class="form-control" 
                   placeholder="Search by address or coordinates (e.g., '123 Main St, San Antonio, TX' or '29.54248, -98.73548')" 
                   @bind="searchQuery"
                   @bind:event="oninput"
                   @onkeydown="HandleSearchKeyPress" />
            <button type="button" 
                    class="btn btn-primary" 
                    @onclick="SearchLocation"
                    disabled="@isSearching">
                @if (isSearching)
                {
                    <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                    <text>Searching...</text>
                }
                else
                {
                    <text>Search</text>
                }
            </button>
        </div>
        @if (!string.IsNullOrWhiteSpace(searchError))
        {
            <div class="alert alert-danger mt-2 mb-0" role="alert">
                @searchError
            </div>
        }
    </div>

    <!-- Toolbar for map editing modes -->
    <div class="btn-toolbar mb-3" role="toolbar">
        <div class="btn-group me-2" role="group">
            <button type="button" 
                    class="btn @(currentMode == MapMode.View ? "btn-primary" : "btn-outline-primary")"
                    @onclick="async () => await SetMode(MapMode.View)">
                View
            </button>
            <button type="button" 
                    class="btn @(currentMode == MapMode.AddVault ? "btn-primary" : "btn-outline-primary")"
                    @onclick="async () => await SetMode(MapMode.AddVault)">
                Add Vault
            </button>
            <button type="button" 
                    class="btn @(currentMode == MapMode.AddMidpoint ? "btn-primary" : "btn-outline-primary")"
                    @onclick="async () => await SetMode(MapMode.AddMidpoint)">
                Add Midpoint
            </button>
            <button type="button" 
                    class="btn @(currentMode == MapMode.DrawCable ? "btn-primary" : "btn-outline-primary")"
                    @onclick="async () => await SetMode(MapMode.DrawCable)">
                Draw Cable
            </button>
            <button type="button" 
                    class="btn @(currentMode == MapMode.Delete ? "btn-primary" : "btn-outline-primary")"
                    @onclick="async () => await SetMode(MapMode.Delete)">
                Delete
            </button>
        </div>
    </div>

    <!-- Status message for current mode -->
    @if (currentMode != MapMode.View)
    {
        <div class="alert alert-info" role="alert">
            @GetModeInstructions()
        </div>
    }

    <!-- Cable drawing progress indicator -->
    @if (currentMode == MapMode.DrawCable && cablePoints.Count > 0)
    {
        <div class="alert alert-warning" role="alert">
            Cable drawing in progress: @cablePoints.Count point(s) added. Click "Finish Cable" to save or "Cancel" to start over.
            <button type="button" class="btn btn-sm btn-success ms-2" @onclick="FinishCable">Finish Cable</button>
            <button type="button" class="btn btn-sm btn-danger ms-2" @onclick="CancelCable">Cancel</button>
        </div>
    }

    <div id="map" class="map-container"></div>
}

@implements IDisposable

@code {
    /// <summary>
    /// Enumeration defining the different interaction modes for the map editor.
    /// </summary>
    private enum MapMode
    {
        View,           // Default mode - no editing, just viewing
        AddVault,       // Click on map to create a new vault
        AddMidpoint,    // Click on map to create a new midpoint
        DrawCable,      // Click multiple points to define a cable path
        Delete          // Click on existing items to delete them
    }

    private Vault[]? vaults;
    private Midpoint[]? midpoints;
    private Cable[]? cables;
    
    private IJSObjectReference? module;
    private IJSObjectReference? mapInstance;
    
    /// <summary>
    /// Current interaction mode for the map editor.
    /// </summary>
    private MapMode currentMode = MapMode.View;

    /// <summary>
    /// Search query entered by the user (address or coordinates).
    /// </summary>
    private string searchQuery = string.Empty;

    /// <summary>
    /// Error message to display if search fails.
    /// </summary>
    private string? searchError;

    /// <summary>
    /// Indicates whether a search operation is currently in progress.
    /// Used to disable the search button and show a loading spinner during search.
    /// </summary>
    private bool isSearching = false;
    
    /// <summary>
    /// Temporary storage for points collected while drawing a cable.
    /// </summary>
    private List<(double Lat, double Lng)> cablePoints = new();
    
    /// <summary>
    /// Temporary polyline reference for previewing the cable being drawn.
    /// </summary>
    private IJSObjectReference? tempCablePolyline;

    /// <summary>
    /// Temporary markers for cable points while drawing (white circles).
    /// </summary>
    private List<IJSObjectReference> tempCableMarkers = new();

    /// <summary>
    /// Dictionary to store vertex markers for each cable (key: cableId, value: list of vertex markers).
    /// </summary>
    private Dictionary<int, List<IJSObjectReference>> cableVertexMarkers = new();

    /// <summary>
    /// Dictionary to store map layer references (markers, circles, polylines) with their entity IDs.
    /// Used to identify which item was clicked for deletion.
    /// Key: Entity ID (vault/midpoint/cable ID), Value: JavaScript object reference to the Leaflet layer
    /// </summary>
    private Dictionary<string, IJSObjectReference> mapLayers = new();

    /// <summary>
    /// .NET object reference for JavaScript interop callbacks.
    /// Used to allow JavaScript to call back into C# methods (e.g., for delete functionality).
    /// </summary>
    private DotNetObjectReference<Home>? dotNetReference;

    protected override async Task OnInitializedAsync()
    {
        try 
        {
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());

            // Fetch all three data types
            vaults = await Http.GetFromJsonAsync<Vault[]>("api/vaults", options);
            midpoints = await Http.GetFromJsonAsync<Midpoint[]>("api/midpoints", options);
            cables = await Http.GetFromJsonAsync<Cable[]>("api/cables", options);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"DATA FETCH ERROR: {ex.Message}");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (mapInstance == null && vaults != null && midpoints != null && cables != null)
        {
            try 
            {
                module = await JS.InvokeAsync<IJSObjectReference>("import", "./mapHelper.js");
                mapInstance = await module.InvokeAsync<IJSObjectReference>("initMap", "map");

                // Setup click event listener for map interactions (needed for delete mode)
                dotNetReference = DotNetObjectReference.Create(this);
                await SetupMapClickListener();
                
                // Initialize delete mode state in JavaScript
                await module.InvokeVoidAsync("setDeleteMode", currentMode == MapMode.Delete);

                // 1. Draw VAULTS (Pins) - Store layer references for deletion
                foreach (var vault in vaults)
                {
                    if (vault.Location != null)
                    {
                        // Build popup content with labeled fields: Name, Status, Description, Coordinates, and link to details
                        string descriptionText = string.IsNullOrWhiteSpace(vault.Description) 
                            ? "No description provided." 
                            : System.Net.WebUtility.HtmlEncode(vault.Description);
                        string coordinates = $"{vault.Location.Y:F6}, {vault.Location.X:F6}";
                        string popup = $"<div style='font-size: 12px; line-height: 1.6;'>" +
                            $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(vault.Name)}<br>" +
                            $"<strong>Status:</strong> {vault.Status}<br>" +
                            $"<strong>Description:</strong> {descriptionText}<br>" +
                            $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                            $"<a href='vault/{vault.Id}' style='margin-top: 8px; display: inline-block;'>View Details</a>" +
                            $"</div>";
                        // Ensure we have a valid color (use status-based color if Color is not set)
                        string vaultColor = !string.IsNullOrWhiteSpace(vault.Color) ? vault.Color : GetStatusColor(vault.Status);
                        // Pass the vault's Color property to display the marker in the correct status color
                        var markerRef = await module.InvokeAsync<IJSObjectReference>("addMarker", mapInstance, vault.Location.Y, vault.Location.X, popup, vault.Id, dotNetReference, vaultColor);
                        mapLayers[$"vault_{vault.Id}"] = markerRef;
                    }
                }

                // 2. Draw MIDPOINTS (Diamond/Square markers) - Store layer references for deletion
                foreach (var mp in midpoints)
                {
                    if (mp.Location != null)
                    {
                        // Build popup content with labeled fields: Name, Status, Description, Coordinates, and link to details
                        string descriptionText = string.IsNullOrWhiteSpace(mp.Description) 
                            ? "No description provided." 
                            : System.Net.WebUtility.HtmlEncode(mp.Description);
                        string coordinates = $"{mp.Location.Y:F6}, {mp.Location.X:F6}";
                        string popup = $"<div style='font-size: 12px; line-height: 1.6;'>" +
                            $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(mp.Name)}<br>" +
                            $"<strong>Status:</strong> {mp.Status}<br>" +
                            $"<strong>Description:</strong> {descriptionText}<br>" +
                            $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                            $"<a href='midpoint/{mp.Id}' style='margin-top: 8px; display: inline-block;'>View Details</a>" +
                            $"</div>";
                        // Ensure we have a valid color (use status-based color if Color is not set)
                        string midpointColor = !string.IsNullOrWhiteSpace(mp.Color) ? mp.Color : GetMidpointStatusColor(mp.Status);
                        // Pass the midpoint's Color property to display the marker in the correct status color
                        var circleRef = await module.InvokeAsync<IJSObjectReference>("addCircle", mapInstance, mp.Location.Y, mp.Location.X, midpointColor, popup, mp.Id, dotNetReference);
                        mapLayers[$"midpoint_{mp.Id}"] = circleRef;
                    }
                }

                // 3. Draw CABLES (Lines) with editable vertices - Store layer references for deletion
                foreach (var cable in cables)
                {
                    if (cable.Path != null)
                    {
                        await DrawCableWithVertices(cable);
                    }
                }
            }
            catch(Exception ex)
            {
                Console.WriteLine($"MAP RENDER ERROR: {ex.Message}");
            }
        }
    }

    /// <summary>
    /// Sets up the click event listener on the map to handle user interactions based on the current mode.
    /// </summary>
    private async Task SetupMapClickListener()
    {
        if (module != null && mapInstance != null)
        {
            // Register a callback that will be invoked from JavaScript when the map is clicked
            var dotNetReference = DotNetObjectReference.Create(this);
            await module.InvokeVoidAsync("addClickEventListener", mapInstance, dotNetReference);
        }
    }

    /// <summary>
    /// Handles clicks on map entities (vaults, midpoints, cables) when in Delete mode.
    /// This method is called from JavaScript when a user clicks on a marker, circle, or polyline.
    /// </summary>
    /// <param name="entityType">The type of entity clicked: "vault", "midpoint", or "cable"</param>
    /// <param name="entityId">The unique ID of the entity to delete</param>
    [JSInvokable]
    public async Task OnEntityClick(string entityType, int entityId)
    {
        // Log for debugging
        Console.WriteLine($"OnEntityClick called: type={entityType}, id={entityId}, currentMode={currentMode}");
        
        // Only handle deletion if we're in Delete mode
        if (currentMode != MapMode.Delete)
        {
            Console.WriteLine($"Not in delete mode, ignoring click. Current mode: {currentMode}");
            return;
        }

        try
        {
            // Show confirmation dialog
            var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to delete this {entityType}?");
            if (!confirmed)
            {
                return;
            }

            // Delete based on entity type
            switch (entityType.ToLower())
            {
                case "vault":
                    await DeleteVault(entityId);
                    break;
                case "midpoint":
                    await DeleteMidpoint(entityId);
                    break;
                case "cable":
                    await DeleteCable(entityId);
                    break;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ERROR deleting {entityType}: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Failed to delete {entityType}. Error: {ex.Message}");
        }
    }

    /// <summary>
    /// Handles marker drag end events when a user moves a vault or midpoint marker to a new location.
    /// This method is called from JavaScript when a marker is dragged and released.
    /// </summary>
    /// <param name="entityType">The type of entity moved: "vault" or "midpoint"</param>
    /// <param name="entityId">The unique ID of the entity that was moved</param>
    /// <param name="newLat">The new latitude coordinate after the drag</param>
    /// <param name="newLng">The new longitude coordinate after the drag</param>
    [JSInvokable]
    public async Task OnMarkerDragEnd(string entityType, int entityId, double newLat, double newLng)
    {
        // Log for debugging
        Console.WriteLine($"OnMarkerDragEnd called: type={entityType}, id={entityId}, newLat={newLat}, newLng={newLng}");

        try
        {
            // Update location based on entity type
            switch (entityType.ToLower())
            {
                case "vault":
                    await UpdateVaultLocation(entityId, newLat, newLng);
                    break;
                case "midpoint":
                    await UpdateMidpointLocation(entityId, newLat, newLng);
                    break;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ERROR updating {entityType} location: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Failed to update {entityType} location. Error: {ex.Message}");
        }
    }

    /// <summary>
    /// Handles map click events from JavaScript. This method is called via JSInterop when the user clicks on the map.
    /// </summary>
    /// <param name="lat">Latitude of the click location.</param>
    /// <param name="lng">Longitude of the click location.</param>
    [JSInvokable]
    public async Task OnMapClick(double lat, double lng)
    {
        if (currentMode == MapMode.View)
        {
            // In view mode, clicks don't do anything
            return;
        }

        try
        {
            switch (currentMode)
            {
                case MapMode.AddVault:
                    await CreateVaultAtLocation(lat, lng);
                    break;

                case MapMode.AddMidpoint:
                    await CreateMidpointAtLocation(lat, lng);
                    break;

                case MapMode.DrawCable:
                    await AddCablePoint(lat, lng);
                    break;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ERROR handling map click: {ex.Message}");
        }

        // Trigger UI update
        StateHasChanged();
    }

    /// <summary>
    /// Changes the current map interaction mode and provides user feedback.
    /// </summary>
    /// <param name="mode">The mode to switch to.</param>
    private async Task SetMode(MapMode mode)
    {
        // If switching away from DrawCable mode, cancel any in-progress cable
        if (currentMode == MapMode.DrawCable && mode != MapMode.DrawCable)
        {
            await CancelCable();
        }

        currentMode = mode;

        // Update JavaScript delete mode state so click handlers know the current mode
        if (module != null)
        {
            await module.InvokeVoidAsync("setDeleteMode", mode == MapMode.Delete);
        }
    }

    /// <summary>
    /// Returns user-friendly instructions for the current map mode.
    /// </summary>
    private string GetModeInstructions()
    {
        return currentMode switch
        {
            MapMode.AddVault => "Click on the map to add a new vault at that location.",
            MapMode.AddMidpoint => "Click on the map to add a new midpoint at that location.",
            MapMode.DrawCable => "Click multiple points on the map to define the cable path. Click 'Finish Cable' when done.",
            MapMode.Delete => "Click on a vault, midpoint, or cable to delete it.",
            _ => ""
        };
    }

    /// <summary>
    /// Creates a new vault at the specified geographic coordinates.
    /// </summary>
    /// <param name="lat">Latitude of the vault location.</param>
    /// <param name="lng">Longitude of the vault location.</param>
    private async Task CreateVaultAtLocation(double lat, double lng)
    {
        if (module == null || mapInstance == null) return;

        // Prompt user for vault name
        var vaultName = await JS.InvokeAsync<string>("prompt", "Enter vault name:");
        if (string.IsNullOrWhiteSpace(vaultName))
        {
            return; // User cancelled
        }

        // Create Point geometry (NetTopologySuite uses X for Longitude, Y for Latitude)
        // SRID 4326 is the standard for GPS (WGS 84)
        var factory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
        var location = factory.CreatePoint(new Coordinate(lng, lat));

        // Create the vault object
        var newVault = new Vault
        {
            Name = vaultName,
            Location = location,
            Status = VaultStatus.New, // New vaults start as "New" (blue)
            Color = GetStatusColor(VaultStatus.New) // Set color based on status
        };

        // Serialize with GeoJSON support
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());

        // POST to API
        var response = await Http.PostAsJsonAsync("api/vaults", newVault, options);
        
        if (response.IsSuccessStatusCode)
        {
            var createdVault = await response.Content.ReadFromJsonAsync<Vault>(options);
            
            if (createdVault != null && createdVault.Location != null && dotNetReference != null)
            {
                // Add marker to map immediately and store reference for deletion
                // Build popup content with labeled fields: Name, Status, Description, Coordinates, and link to details
                string descriptionText = string.IsNullOrWhiteSpace(createdVault.Description) 
                    ? "No description provided." 
                    : System.Net.WebUtility.HtmlEncode(createdVault.Description);
                string coordinates = $"{createdVault.Location.Y:F6}, {createdVault.Location.X:F6}";
                string popup = $"<div style='font-size: 12px; line-height: 1.6;'>" +
                    $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(createdVault.Name)}<br>" +
                    $"<strong>Status:</strong> {createdVault.Status}<br>" +
                    $"<strong>Description:</strong> {descriptionText}<br>" +
                    $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                    $"<a href='vault/{createdVault.Id}' style='margin-top: 8px; display: inline-block;'>View Details</a>" +
                    $"</div>";
                // Pass the vault's Color property to display the marker in the correct status color
                var markerRef = await module.InvokeAsync<IJSObjectReference>("addMarker", mapInstance, createdVault.Location.Y, createdVault.Location.X, popup, createdVault.Id, dotNetReference, createdVault.Color);
                mapLayers[$"vault_{createdVault.Id}"] = markerRef;

                // Refresh the vaults list
                await LoadVaults();
            }
        }
    }

    /// <summary>
    /// Creates a new midpoint at the specified geographic coordinates.
    /// </summary>
    /// <param name="lat">Latitude of the midpoint location.</param>
    /// <param name="lng">Longitude of the midpoint location.</param>
    private async Task CreateMidpointAtLocation(double lat, double lng)
    {
        if (module == null || mapInstance == null) return;

        // Prompt user for midpoint name
        var midpointName = await JS.InvokeAsync<string>("prompt", "Enter midpoint name:");
        if (string.IsNullOrWhiteSpace(midpointName))
        {
            return; // User cancelled
        }

        // Create Point geometry
        // SRID 4326 is the standard for GPS (WGS 84)
        var factory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
        var location = factory.CreatePoint(new Coordinate(lng, lat));

        // Create the midpoint object
        var newMidpoint = new Midpoint
        {
            Name = midpointName,
            Location = location,
            Status = MidpointStatus.New, // New midpoints start as "New" (black)
            Color = GetMidpointStatusColor(MidpointStatus.New) // Set color based on status
        };

        // Serialize with GeoJSON support
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());

        // POST to API
        var response = await Http.PostAsJsonAsync("api/midpoints", newMidpoint, options);
        
        if (response.IsSuccessStatusCode)
        {
            var createdMidpoint = await response.Content.ReadFromJsonAsync<Midpoint>(options);
            
            if (createdMidpoint != null && createdMidpoint.Location != null && dotNetReference != null)
            {
                // Add circle to map immediately and store reference for deletion
                // Build popup content with labeled fields: Name, Status, Description, Coordinates, and link to details
                string descriptionText = string.IsNullOrWhiteSpace(createdMidpoint.Description) 
                    ? "No description provided." 
                    : System.Net.WebUtility.HtmlEncode(createdMidpoint.Description);
                string coordinates = $"{createdMidpoint.Location.Y:F6}, {createdMidpoint.Location.X:F6}";
                string popup = $"<div style='font-size: 12px; line-height: 1.6;'>" +
                    $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(createdMidpoint.Name)}<br>" +
                    $"<strong>Status:</strong> {createdMidpoint.Status}<br>" +
                    $"<strong>Description:</strong> {descriptionText}<br>" +
                    $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                    $"<a href='midpoint/{createdMidpoint.Id}' style='margin-top: 8px; display: inline-block;'>View Details</a>" +
                    $"</div>";
                // Pass the midpoint's Color property to display the marker in the correct status color
                var circleRef = await module.InvokeAsync<IJSObjectReference>("addCircle", mapInstance, createdMidpoint.Location.Y, createdMidpoint.Location.X, createdMidpoint.Color, popup, createdMidpoint.Id, dotNetReference);
                mapLayers[$"midpoint_{createdMidpoint.Id}"] = circleRef;

                // Refresh the midpoints list
                await LoadMidpoints();
            }
        }
    }

    /// <summary>
    /// Adds a point to the current cable being drawn and updates the preview polyline.
    /// Shows white circle markers at each point as it's added (similar to Google My Maps).
    /// </summary>
    /// <param name="lat">Latitude of the point.</param>
    /// <param name="lng">Longitude of the point.</param>
    private async Task AddCablePoint(double lat, double lng)
    {
        if (module == null || mapInstance == null) return;

        // Add point to collection
        cablePoints.Add((lat, lng));

        // Add a white circle marker at this point (visible vertex)
        var marker = await module.InvokeAsync<IJSObjectReference>("addCableVertexMarker", mapInstance, lat, lng);
        tempCableMarkers.Add(marker);

        // If we have at least 2 points, draw/update the preview polyline
        if (cablePoints.Count >= 2)
        {
            // Remove previous preview if it exists
            if (tempCablePolyline != null)
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, tempCablePolyline);
            }

            // Create array of coordinates for the preview
            var latLngs = cablePoints.Select(p => new { lat = p.Lat, lng = p.Lng }).ToList<object>();
            
            // Draw preview polyline in orange
            tempCablePolyline = await module.InvokeAsync<IJSObjectReference>("addPolyline", mapInstance, latLngs, "Orange", "Preview - Click 'Finish Cable' to save");
        }
    }

    /// <summary>
    /// Completes the cable drawing by saving the collected points as a LineString to the database.
    /// </summary>
    private async Task FinishCable()
    {
        if (cablePoints.Count < 2)
        {
            await JS.InvokeVoidAsync("alert", "A cable needs at least 2 points. Please add more points before finishing.");
            return;
        }

        // Prompt user for cable name
        var cableName = await JS.InvokeAsync<string>("prompt", "Enter cable name:");
        if (string.IsNullOrWhiteSpace(cableName))
        {
            return; // User cancelled
        }

        // Create LineString from collected points (NetTopologySuite uses X for Longitude, Y for Latitude)
        // SRID 4326 is the standard for GPS (WGS 84)
        var factory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
        var coordinates = cablePoints.Select(p => new Coordinate(p.Lng, p.Lat)).ToArray();
        var lineString = factory.CreateLineString(coordinates);

        // Create the cable object with default black color
        var newCable = new Cable
        {
            Name = cableName,
            Path = lineString,
            Color = "Black" // Default color for newly drawn cables
        };

        // Serialize with GeoJSON support
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());

        // POST to API
        var response = await Http.PostAsJsonAsync("api/cables", newCable, options);
        
        if (response.IsSuccessStatusCode)
        {
            var createdCable = await response.Content.ReadFromJsonAsync<Cable>(options);
            
            if (createdCable != null && createdCable.Path != null && module != null && mapInstance != null)
            {
                // Remove preview polyline and temporary markers
                if (tempCablePolyline != null)
                {
                    await module.InvokeVoidAsync("removeLayer", mapInstance, tempCablePolyline);
                    tempCablePolyline = null;
                }
                
                // Remove all temporary markers
                foreach (var marker in tempCableMarkers)
                {
                    await module.InvokeVoidAsync("removeLayer", mapInstance, marker);
                }
                tempCableMarkers.Clear();

                // Draw the saved cable with editable vertices
                await DrawCableWithVertices(createdCable);

                // Refresh the cables list
                await LoadCables();
            }

            // Reset cable drawing state
            cablePoints.Clear();
            currentMode = MapMode.View;
        }
    }

    /// <summary>
    /// Cancels the current cable drawing operation and clears the preview.
    /// </summary>
    private async Task CancelCable()
    {
        if (module != null && mapInstance != null)
        {
            if (tempCablePolyline != null)
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, tempCablePolyline);
                tempCablePolyline = null;
            }
            
            // Remove all temporary markers
            foreach (var marker in tempCableMarkers)
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, marker);
            }
            tempCableMarkers.Clear();
        }
        cablePoints.Clear();
        currentMode = MapMode.View;
    }

    /// <summary>
    /// Draws a cable on the map with editable vertex markers (white circles).
    /// Each vertex can be dragged to adjust the cable shape.
    /// </summary>
    /// <param name="cable">The cable to draw</param>
    private async Task DrawCableWithVertices(Cable cable)
    {
        if (module == null || mapInstance == null || cable.Path == null || dotNetReference == null)
            return;

        // Remove existing cable and vertex markers if they exist (for redrawing after updates)
        if (mapLayers.ContainsKey($"cable_{cable.Id}"))
        {
            await module.InvokeVoidAsync("removeLayer", mapInstance, mapLayers[$"cable_{cable.Id}"]);
            mapLayers.Remove($"cable_{cable.Id}");
        }
        
        if (cableVertexMarkers.ContainsKey(cable.Id))
        {
            foreach (var vertexMarker in cableVertexMarkers[cable.Id])
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, vertexMarker);
            }
            cableVertexMarkers.Remove(cable.Id);
        }

        // Convert coordinates to Leaflet format
        var latLngs = new List<object>();
        foreach (var coord in cable.Path.Coordinates)
        {
            latLngs.Add(new { lat = coord.Y, lng = coord.X });
        }

        // Build popup content
        string descriptionText = string.IsNullOrWhiteSpace(cable.Description) 
            ? "No description provided." 
            : System.Net.WebUtility.HtmlEncode(cable.Description);
        string lengthText = GetCableLengthForPopup(cable);
        string popup = $"<div style='font-size: 12px; line-height: 1.6;'>" +
            $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(cable.Name)}<br>" +
            $"<strong>Description:</strong> {descriptionText}<br>" +
            $"<strong>Color:</strong> {cable.Color}<br>" +
            $"<strong>Length:</strong> {lengthText}<br>" +
            $"<a href='cable/{cable.Id}' style='margin-top: 8px; display: inline-block;'>View Details</a>" +
            $"</div>";

        // Draw the polyline with drag support
        var polylineRef = await module.InvokeAsync<IJSObjectReference>("addEditablePolyline", 
            mapInstance, latLngs, cable.Color, popup, cable.Id, dotNetReference);
        mapLayers[$"cable_{cable.Id}"] = polylineRef;

        // Store vertex markers for this cable
        var vertexMarkers = new List<IJSObjectReference>();
        int vertexIndex = 0;
        foreach (var coord in cable.Path.Coordinates)
        {
            var vertexMarker = await module.InvokeAsync<IJSObjectReference>("addCableVertexMarker", 
                mapInstance, coord.Y, coord.X);
            
            // Make the vertex marker draggable and connect it to the cable
            // This returns a draggable marker (replaces the circle marker)
            var draggableMarker = await module.InvokeAsync<IJSObjectReference>("makeVertexDraggable", 
                mapInstance, vertexMarker, cable.Id, vertexIndex, polylineRef, dotNetReference);
            
            vertexMarkers.Add(draggableMarker);
            vertexIndex++;
        }
        
        cableVertexMarkers[cable.Id] = vertexMarkers;
    }

    /// <summary>
    /// Reloads the vaults from the API and refreshes the display.
    /// </summary>
    private async Task LoadVaults()
    {
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());
        vaults = await Http.GetFromJsonAsync<Vault[]>("api/vaults", options);
    }

    /// <summary>
    /// Reloads the midpoints from the API and refreshes the display.
    /// </summary>
    private async Task LoadMidpoints()
    {
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());
        midpoints = await Http.GetFromJsonAsync<Midpoint[]>("api/midpoints", options);
    }

    /// <summary>
    /// Reloads the cables from the API and refreshes the display.
    /// </summary>
    private async Task LoadCables()
    {
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        options.Converters.Add(new GeoJsonConverterFactory());
        cables = await Http.GetFromJsonAsync<Cable[]>("api/cables", options);
    }

    /// <summary>
    /// Deletes a vault from the database and removes it from the map.
    /// </summary>
    /// <param name="vaultId">The unique ID of the vault to delete</param>
    private async Task DeleteVault(int vaultId)
    {
        if (module == null || mapInstance == null) return;

        // Call API to delete the vault
        var response = await Http.DeleteAsync($"api/vaults/{vaultId}");

        if (response.IsSuccessStatusCode)
        {
            // Remove from map
            var layerKey = $"vault_{vaultId}";
            if (mapLayers.ContainsKey(layerKey))
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, mapLayers[layerKey]);
                mapLayers.Remove(layerKey);
            }

            // Refresh the vaults list
            await LoadVaults();
            
            // Refresh the map display
            StateHasChanged();
        }
        else
        {
            await JS.InvokeVoidAsync("alert", "Failed to delete vault. Please try again.");
        }
    }

    /// <summary>
    /// Deletes a midpoint from the database and removes it from the map.
    /// </summary>
    /// <param name="midpointId">The unique ID of the midpoint to delete</param>
    private async Task DeleteMidpoint(int midpointId)
    {
        if (module == null || mapInstance == null) return;

        // Call API to delete the midpoint
        var response = await Http.DeleteAsync($"api/midpoints/{midpointId}");

        if (response.IsSuccessStatusCode)
        {
            // Remove from map
            var layerKey = $"midpoint_{midpointId}";
            if (mapLayers.ContainsKey(layerKey))
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, mapLayers[layerKey]);
                mapLayers.Remove(layerKey);
            }

            // Refresh the midpoints list
            await LoadMidpoints();
            
            // Refresh the map display
            StateHasChanged();
        }
        else
        {
            await JS.InvokeVoidAsync("alert", "Failed to delete midpoint. Please try again.");
        }
    }

    /// <summary>
    /// Deletes a cable from the database and removes it from the map, including all vertex markers.
    /// </summary>
    /// <param name="cableId">The unique ID of the cable to delete</param>
    private async Task DeleteCable(int cableId)
    {
        if (module == null || mapInstance == null) return;

        // Call API to delete the cable
        var response = await Http.DeleteAsync($"api/cables/{cableId}");

        if (response.IsSuccessStatusCode)
        {
            // Remove polyline from map
            var layerKey = $"cable_{cableId}";
            if (mapLayers.ContainsKey(layerKey))
            {
                await module.InvokeVoidAsync("removeLayer", mapInstance, mapLayers[layerKey]);
                mapLayers.Remove(layerKey);
            }
            
            // Remove all vertex markers for this cable
            if (cableVertexMarkers.ContainsKey(cableId))
            {
                foreach (var vertexMarker in cableVertexMarkers[cableId])
                {
                    await module.InvokeVoidAsync("removeLayer", mapInstance, vertexMarker);
                }
                cableVertexMarkers.Remove(cableId);
            }

            // Refresh the cables list
            await LoadCables();
            
            // Refresh the map display
            StateHasChanged();
        }
        else
        {
            await JS.InvokeVoidAsync("alert", "Failed to delete cable. Please try again.");
        }
    }

    /// <summary>
    /// Gets the color name string based on the vault status.
    /// Used to set the Color property when creating or updating vaults.
    /// Maps status colors: New (blue), Pending (brown), Review (gray), Complete (green), Issue (red).
    /// </summary>
    /// <param name="status">The vault status to get the color for</param>
    /// <returns>A color name string (e.g., "Blue", "Brown", "Gray", "Green", "Red")</returns>
    private string GetStatusColor(VaultStatus status)
    {
        return status switch
        {
            VaultStatus.New => "Blue",
            VaultStatus.Pending => "Brown",
            VaultStatus.Review => "Gray",
            VaultStatus.Complete => "Green",
            VaultStatus.Issue => "Red",
            _ => "Blue" // Default to blue
        };
    }

    /// <summary>
    /// Gets the color name string based on the midpoint status.
    /// Used to set the Color property when creating or updating midpoints.
    /// Maps status colors: New (black), Review (light gray), Complete (light green), Issue (light red).
    /// </summary>
    /// <param name="status">The midpoint status to get the color for</param>
    /// <returns>A color name string (e.g., "Black", "LightGray", "LightGreen", "LightCoral")</returns>
    private string GetMidpointStatusColor(MidpointStatus status)
    {
        return status switch
        {
            MidpointStatus.New => "Black",
            MidpointStatus.Review => "LightGray",
            MidpointStatus.Complete => "LightGreen",
            MidpointStatus.Issue => "LightCoral",
            _ => "Black" // Default to black
        };
    }

    /// <summary>
    /// Updates a vault's location after it has been dragged to a new position on the map.
    /// </summary>
    /// <param name="vaultId">The unique ID of the vault to update</param>
    /// <param name="newLat">The new latitude coordinate</param>
    /// <param name="newLng">The new longitude coordinate</param>
    private async Task UpdateVaultLocation(int vaultId, double newLat, double newLng)
    {
        if (module == null || mapInstance == null) return;

        try
        {
            // First, get the current vault to preserve other properties
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            
            var vault = await Http.GetFromJsonAsync<Vault>($"api/vaults/{vaultId}", options);
            if (vault == null)
            {
                await JS.InvokeVoidAsync("alert", "Vault not found.");
                return;
            }

            // Create a new Point with the new coordinates (X=Longitude, Y=Latitude)
            var geometryFactory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
            var newLocation = geometryFactory.CreatePoint(new Coordinate(newLng, newLat));

            // Update the vault with the new location
            var updatedVault = new Vault
            {
                Id = vault.Id,
                Name = vault.Name,
                Status = vault.Status,
                Description = vault.Description,
                Color = vault.Color,
                Location = newLocation // Update the location
            };

            // Send PUT request to update the vault location
            var response = await Http.PutAsJsonAsync($"api/vaults/{vaultId}", updatedVault, options);

            if (response.IsSuccessStatusCode)
            {
                // Update the popup with new coordinates
                string descriptionText = string.IsNullOrWhiteSpace(updatedVault.Description) 
                    ? "No description provided." 
                    : System.Net.WebUtility.HtmlEncode(updatedVault.Description);
                string coordinates = $"{newLat:F6}, {newLng:F6}";
                string newPopup = $"<div style='font-size: 12px; line-height: 1.6;'>" +
                    $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(updatedVault.Name)}<br>" +
                    $"<strong>Status:</strong> {updatedVault.Status}<br>" +
                    $"<strong>Description:</strong> {descriptionText}<br>" +
                    $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                    $"<a href='vault/{updatedVault.Id}' style='margin-top: 8px; display: inline-block;'>View Details</a>" +
                    $"</div>";
                
                // Update the marker's popup content
                var layerKey = $"vault_{vaultId}";
                if (mapLayers.ContainsKey(layerKey))
                {
                    await module.InvokeVoidAsync("updateMarkerPopup", mapLayers[layerKey], newPopup);
                }

                // Refresh the vaults list to get updated data
                await LoadVaults();
            }
            else
            {
                var errorMessage = await response.Content.ReadAsStringAsync();
                await JS.InvokeVoidAsync("alert", $"Failed to update vault location: {errorMessage}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating vault location: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Error updating vault location: {ex.Message}");
        }
    }

    /// <summary>
    /// Updates a midpoint's location after it has been dragged to a new position on the map.
    /// </summary>
    /// <param name="midpointId">The unique ID of the midpoint to update</param>
    /// <param name="newLat">The new latitude coordinate</param>
    /// <param name="newLng">The new longitude coordinate</param>
    private async Task UpdateMidpointLocation(int midpointId, double newLat, double newLng)
    {
        if (module == null || mapInstance == null) return;

        try
        {
            // First, get the current midpoint to preserve other properties
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            
            var midpoint = await Http.GetFromJsonAsync<Midpoint>($"api/midpoints/{midpointId}", options);
            if (midpoint == null)
            {
                await JS.InvokeVoidAsync("alert", "Midpoint not found.");
                return;
            }

            // Create a new Point with the new coordinates (X=Longitude, Y=Latitude)
            var geometryFactory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
            var newLocation = geometryFactory.CreatePoint(new Coordinate(newLng, newLat));

            // Update the midpoint with the new location
            var updatedMidpoint = new Midpoint
            {
                Id = midpoint.Id,
                Name = midpoint.Name,
                Status = midpoint.Status,
                Description = midpoint.Description,
                Color = midpoint.Color,
                Location = newLocation // Update the location
            };

            // Send PUT request to update the midpoint location
            var response = await Http.PutAsJsonAsync($"api/midpoints/{midpointId}", updatedMidpoint, options);

            if (response.IsSuccessStatusCode)
            {
                // Update the popup with new coordinates
                string descriptionText = string.IsNullOrWhiteSpace(updatedMidpoint.Description) 
                    ? "No description provided." 
                    : System.Net.WebUtility.HtmlEncode(updatedMidpoint.Description);
                string coordinates = $"{newLat:F6}, {newLng:F6}";
                string newPopup = $"<div style='font-size: 12px; line-height: 1.6;'>" +
                    $"<strong>Name:</strong> {System.Net.WebUtility.HtmlEncode(updatedMidpoint.Name)}<br>" +
                    $"<strong>Status:</strong> {updatedMidpoint.Status}<br>" +
                    $"<strong>Description:</strong> {descriptionText}<br>" +
                    $"<strong>Coordinates:</strong> {coordinates} (Lat, Lng)<br>" +
                    $"<a href='midpoint/{updatedMidpoint.Id}' style='margin-top: 8px; display: inline-block;'>View Details</a>" +
                    $"</div>";
                
                // Update the marker's popup content
                var layerKey = $"midpoint_{midpointId}";
                if (mapLayers.ContainsKey(layerKey))
                {
                    await module.InvokeVoidAsync("updateMarkerPopup", mapLayers[layerKey], newPopup);
                }

                // Refresh the midpoints list to get updated data
                await LoadMidpoints();
            }
            else
            {
                var errorMessage = await response.Content.ReadAsStringAsync();
                await JS.InvokeVoidAsync("alert", $"Failed to update midpoint location: {errorMessage}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating midpoint location: {ex.Message}");
            await JS.InvokeVoidAsync("alert", $"Error updating midpoint location: {ex.Message}");
        }
    }

    /// <summary>
    /// Calculates and formats the cable length for display in popups.
    /// Uses the Haversine formula to calculate the great-circle distance between consecutive points,
    /// then converts the result from meters to feet for display.
    /// </summary>
    /// <param name="cable">The cable object containing the Path LineString</param>
    /// <returns>A formatted string showing the length in feet</returns>
    private string GetCableLengthForPopup(Cable? cable)
    {
        if (cable?.Path == null || cable.Path.NumPoints < 2)
        {
            return "N/A";
        }

        double totalLengthMeters = 0.0;
        var coordinates = cable.Path.Coordinates;

        // Calculate distance between consecutive points using Haversine formula
        for (int i = 0; i < coordinates.Length - 1; i++)
        {
            var point1 = coordinates[i];
            var point2 = coordinates[i + 1];
            
            // Haversine formula to calculate distance between two lat/lng points
            double lat1 = point1.Y * Math.PI / 180.0; // Convert to radians
            double lat2 = point2.Y * Math.PI / 180.0;
            double deltaLat = (point2.Y - point1.Y) * Math.PI / 180.0;
            double deltaLng = (point2.X - point1.X) * Math.PI / 180.0;

            double a = Math.Sin(deltaLat / 2) * Math.Sin(deltaLat / 2) +
                       Math.Cos(lat1) * Math.Cos(lat2) *
                       Math.Sin(deltaLng / 2) * Math.Sin(deltaLng / 2);
            double c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
            
            // Earth's radius in meters (WGS84)
            const double earthRadiusMeters = 6371000.0;
            double distanceMeters = earthRadiusMeters * c;
            
            totalLengthMeters += distanceMeters;
        }

        // Convert meters to feet (1 meter = 3.28084 feet)
        const double metersToFeet = 3.28084;
        double totalLengthFeet = totalLengthMeters * metersToFeet;

        // Format the result for popup (shorter format)
        if (totalLengthFeet < 5280) // Less than 1 mile
        {
            return $"{totalLengthFeet:F1} ft";
        }
        else
        {
            // Display in miles for longer cables
            double miles = totalLengthFeet / 5280.0;
            return $"{miles:F2} mi";
        }
    }

    /// <summary>
    /// Handles the Enter key press in the search input field.
    /// Triggers the search when the user presses Enter.
    /// </summary>
    /// <param name="e">Keyboard event arguments</param>
    private async Task HandleSearchKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !isSearching && !string.IsNullOrWhiteSpace(searchQuery))
        {
            await SearchLocation();
        }
    }

    /// <summary>
    /// Searches for a location by address or coordinates and navigates the map to that location.
    /// Supports two input formats:
    /// 1. Street addresses (e.g., "123 Main St, San Antonio, TX") - uses Nominatim geocoding
    /// 2. Coordinates (e.g., "29.54248, -98.73548" or "29.54248,-98.73548") - parses directly
    /// </summary>
    private async Task SearchLocation()
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            searchError = "Please enter an address or coordinates to search.";
            return;
        }

        isSearching = true;
        searchError = null;
        StateHasChanged();

        try
        {
            // Try to parse as coordinates first (format: "lat, lng" or "lat,lng")
            if (TryParseCoordinates(searchQuery, out double lat, out double lng))
            {
                // Valid coordinates - navigate directly
                await NavigateToLocation(lat, lng);
            }
            else
            {
                // Not coordinates - treat as address and geocode
                await GeocodeAddress(searchQuery);
            }
        }
        catch (Exception ex)
        {
            searchError = $"Search failed: {ex.Message}";
            Console.WriteLine($"Search error: {ex.Message}");
        }
        finally
        {
            isSearching = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Attempts to parse the search query as coordinates (latitude, longitude).
    /// Supports formats like "29.54248, -98.73548" or "29.54248,-98.73548".
    /// </summary>
    /// <param name="query">The search query to parse</param>
    /// <param name="lat">Output parameter for the parsed latitude</param>
    /// <param name="lng">Output parameter for the parsed longitude</param>
    /// <returns>True if the query was successfully parsed as coordinates, false otherwise</returns>
    private bool TryParseCoordinates(string query, out double lat, out double lng)
    {
        lat = 0;
        lng = 0;

        // Remove whitespace and split by comma
        var parts = query.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        
        if (parts.Length == 2)
        {
            // Try to parse both parts as doubles
            if (double.TryParse(parts[0], out lat) && double.TryParse(parts[1], out lng))
            {
                // Validate coordinate ranges (latitude: -90 to 90, longitude: -180 to 180)
                if (lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180)
                {
                    return true;
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Geocodes an address using the Nominatim API (OpenStreetMap's geocoding service).
    /// This converts a street address into latitude/longitude coordinates.
    /// </summary>
    /// <param name="address">The address to geocode (e.g., "123 Main St, San Antonio, TX")</param>
    private async Task GeocodeAddress(string address)
    {
        try
        {
            // Use Nominatim (OpenStreetMap's geocoding service) - free, no API key required
            // Note: Nominatim has usage policies - be respectful with request frequency
            var encodedAddress = System.Net.WebUtility.UrlEncode(address);
            var nominatimUrl = $"https://nominatim.openstreetmap.org/search?q={encodedAddress}&format=json&limit=1";

            // Create HTTP request with proper headers (Nominatim requires a User-Agent)
            var request = new HttpRequestMessage(HttpMethod.Get, nominatimUrl);
            request.Headers.Add("User-Agent", "FOMSApp/1.0"); // Required by Nominatim usage policy

            var response = await Http.SendAsync(request);

            if (response.IsSuccessStatusCode)
            {
                var jsonContent = await response.Content.ReadAsStringAsync();
                var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                
                // Nominatim returns an array of results
                var results = JsonSerializer.Deserialize<JsonElement[]>(jsonContent, options);

                if (results != null && results.Length > 0)
                {
                    var firstResult = results[0];
                    
                    // Extract latitude and longitude from the result
                    if (firstResult.TryGetProperty("lat", out var latElement) &&
                        firstResult.TryGetProperty("lon", out var lngElement))
                    {
                        if (double.TryParse(latElement.GetString(), out double lat) &&
                            double.TryParse(lngElement.GetString(), out double lng))
                        {
                            await NavigateToLocation(lat, lng);
                            return;
                        }
                    }
                }

                searchError = "Address not found. Please try a more specific address or use coordinates.";
            }
            else
            {
                searchError = $"Geocoding service error: {response.StatusCode}";
            }
        }
        catch (Exception ex)
        {
            searchError = $"Failed to geocode address: {ex.Message}";
            Console.WriteLine($"Geocoding error: {ex.Message}");
        }
    }

    /// <summary>
    /// Navigates the map to the specified location by panning and zooming.
    /// </summary>
    /// <param name="lat">The target latitude</param>
    /// <param name="lng">The target longitude</param>
    private async Task NavigateToLocation(double lat, double lng)
    {
        if (module == null || mapInstance == null)
        {
            searchError = "Map not initialized. Please wait for the map to load.";
            return;
        }

        try
        {
            // Call JavaScript function to pan and zoom the map to the location
            await module.InvokeVoidAsync("navigateToLocation", mapInstance, lat, lng);
            searchError = null; // Clear any previous errors
        }
        catch (Exception ex)
        {
            searchError = $"Failed to navigate to location: {ex.Message}";
            Console.WriteLine($"Navigation error: {ex.Message}");
        }
    }

    /// <summary>
    /// Handles when a cable vertex is dragged to a new location.
    /// Updates the cable's path in the database and refreshes the display.
    /// </summary>
    /// <param name="cableId">The ID of the cable being modified</param>
    /// <param name="vertexIndex">The index of the vertex that was moved</param>
    /// <param name="newLat">The new latitude of the vertex</param>
    /// <param name="newLng">The new longitude of the vertex</param>
    [JSInvokable]
    public async Task OnCableVertexDragEnd(int cableId, int vertexIndex, double newLat, double newLng)
    {
        try
        {
            // Get the current cable
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            
            var cable = await Http.GetFromJsonAsync<Cable>($"api/cables/{cableId}", options);
            if (cable == null || cable.Path == null) return;

            // Update the coordinate at the specified index
            var coordinates = cable.Path.Coordinates.ToList();
            if (vertexIndex >= 0 && vertexIndex < coordinates.Count)
            {
                coordinates[vertexIndex] = new Coordinate(newLng, newLat);
                
                // Create new LineString with updated coordinates
                var factory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
                var newPath = factory.CreateLineString(coordinates.ToArray());
                
                // Update the cable
                cable.Path = newPath;
                
                // Send PUT request to update the cable path
                var response = await Http.PutAsJsonAsync($"api/cables/{cableId}", cable, options);
                
                if (response.IsSuccessStatusCode)
                {
                    // Reload the specific cable and redraw it with updated vertices
                    var updatedCable = await Http.GetFromJsonAsync<Cable>($"api/cables/{cableId}", options);
                    if (updatedCable != null)
                    {
                        await DrawCableWithVertices(updatedCable);
                        StateHasChanged();
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating cable vertex: {ex.Message}");
        }
    }

    /// <summary>
    /// Handles when an entire cable is dragged to a new location.
    /// Moves all vertices by the same offset.
    /// </summary>
    /// <param name="cableId">The ID of the cable being moved</param>
    /// <param name="deltaLat">The change in latitude</param>
    /// <param name="deltaLng">The change in longitude</param>
    [JSInvokable]
    public async Task OnCableDragEnd(int cableId, double deltaLat, double deltaLng)
    {
        try
        {
            // Get the current cable
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            options.Converters.Add(new GeoJsonConverterFactory());
            
            var cable = await Http.GetFromJsonAsync<Cable>($"api/cables/{cableId}", options);
            if (cable == null || cable.Path == null) return;

            // Update all coordinates by the delta
            var coordinates = cable.Path.Coordinates.Select(c => 
                new Coordinate(c.X + deltaLng, c.Y + deltaLat)).ToArray();
            
            // Create new LineString with updated coordinates
            var factory = NtsGeometryServices.Instance.CreateGeometryFactory(srid: 4326);
            var newPath = factory.CreateLineString(coordinates);
            
            // Update the cable
            cable.Path = newPath;
            
            // Send PUT request to update the cable path
            var response = await Http.PutAsJsonAsync($"api/cables/{cableId}", cable, options);
            
            if (response.IsSuccessStatusCode)
            {
                // Reload the cable and redraw it
                await LoadCables();
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error moving cable: {ex.Message}");
        }
    }

    /// <summary>
    /// Cleanup method to dispose of resources when the component is destroyed.
    /// Prevents memory leaks by disposing the DotNetObjectReference.
    /// </summary>
    public void Dispose()
    {
        dotNetReference?.Dispose();
    }
}